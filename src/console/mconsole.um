// console 
//
// terms:
//  block: block of text. similar to line in console, but can have multiple lines inside it

import (
	"rect.um"
	"th.um"
	"canvas.um"
	th_color = "color.um"
	th_font = "font.um"
)

type Console* = struct {
	blocks: []str
}

fn (con: ^Console) write*(block: str) {
	con.blocks = append(con.blocks, block)
}


type RenderPass = struct {
	rect: rect.Rect
	pos: th.Vf2
	font: th_font.Font
}

fn blockRect*(pass: ^RenderPass, block: str): rect.Rect {
	height := pass.font.measure(block).y

	return rect.Rect{pass.rect.x, pass.pos.y-height,
									 pass.rect.w, height}
}

// renders a single block and moves upwards
fn renderBlock*(pass: ^RenderPass, block: str, color: uint32) {
	height := pass.font.measure(block).y
	pass.pos.y -= height

	pass.font.draw(block, pass.pos, color)
}

// NOTE: this function does not clip
fn render*(con: ^Console, font: th_font.Font, r: rect.Rect) {
	end := th.Vf2{r.x, r.y+r.h}
	pass := RenderPass{r, end, font}
	fade := 0.9
	alpha := 1.0

	canvas.drawRect(th_color.alpha(th.black, 0.95), r)

	for i in con.blocks {
		block := con.blocks[len(con.blocks)-i-1]
		if i % 2 == 0 {
			canvas.drawRect(th_color.alpha(th.white, alpha*0.05), blockRect(&pass, block))	
		}

		renderBlock(&pass, block, th_color.alpha(th.white, alpha))
		alpha *= fade
	}
}