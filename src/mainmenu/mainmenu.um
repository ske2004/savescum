import (
  "window.um"
  "image.um"
  "th.um"
  "atlas.um"
  "rect.um"
  "canvas.um"
  "input.um"

  "../data/resources.um"
  "../data/problem_screen.um"
  "../shared/global.um"
  "../misc/immcursor.um"
  "../gfx/background.um"
  "../game/game.um"
  "../editor/editor.um"
  "../game/world.um"
  "../game/world_data.um"
  "../misc/util.um"

  "../ui/ui.um"
)

type Callbacks* = struct {
  frameCb:   fn()
  destroyCb: fn()
}

type MainMenu* = struct {
  tileset:   image::Image
  rl:        ^resources::ResourceLoader
  ui:        ^ui::UI
  callbacks: Callbacks
  viewExit:  bool
}

fn mk*(ui: ^ui::UI, rl: ^resources::ResourceLoader): ^MainMenu {
  return new(MainMenu, {ui: ui, tileset: resources::loadImage(rl, "data/img/ts_sky.png", .linear), rl: rl})
}

fn setup*() {
  dpi := window::getDpiScaleFactor()
  global::screen = {0, 0, 800*dpi, 600*dpi}
  window::setup("Savescum", trunc(global::screen.w), trunc(global::screen.h))
}

fn (menu: ^MainMenu) setupGame*() {
  tileset := atlas::mk(menu.tileset, {4, 9})
  world := world::fromTileset(tileset)
  worldData := world_data::load(world, util::readFileStr("data/spiel/sc_wip.csv").item0)
  game::start(worldData)
  menu.callbacks.frameCb   = { game::update(); game::draw() }
  menu.callbacks.destroyCb = {}
}

fn (menu: ^MainMenu) setupEditor*() {
  editor := editor::mk(menu.ui, menu.rl)
  menu.callbacks.frameCb = |editor| { editor.update(.editor) }
  menu.callbacks.destroyCb = |editor| { editor.destroy() }

  if menu.rl.hasErrors() {
    problem_screen::setup(menu.rl)
  }
}

fn (menu: ^MainMenu) showExit(ui: ^ui::UI) {
  ui.cellRect(ui.io.screen)
  ui.cellAlign(0.5)
  ui.col(|menu| {
    ui.drawCustom({
      canvas::drawRect(0x00000044, dest)
    })

    ui.cellJustify(1.0)
    ui.cellAlign(0.5)
    ui.col(|menu| {
      ui.spring(1)
      ui.cellColor(0xFFFFFFFF)
      ui.heading("SAVESCUM")
      ui.cellStretch()
      if ui.button("Return") {
        menu.viewExit = false
      }
      ui.cellStretch()
      if ui.button("Exit to main menu") {
        if valid(menu.callbacks.destroyCb) {
          menu.callbacks.destroyCb()
        }
        menu.callbacks = {}
        menu.viewExit = false
      }
      ui.spring(1)
    })
  })
}

fn (menu: ^MainMenu) update*() {
  // @TODO: Somehow handle all this automatically, because it's also handled in the editor.
  global::screen = rect::Rect{0, 0, window::w, window::h}
  window::setViewport({window::w, window::h})
  
  if valid(menu.callbacks.frameCb) {
    menu.callbacks.frameCb()

    if input::isJustPressed(.escape) {
      input::clear(.escape)
      menu.viewExit = !menu.viewExit
    }

    if menu.viewExit {
      menu.ui.pass(|menu| {
        menu.showExit(menu.ui)
      })
    }
    return
  }
  
  immcursor::setCursor(.system)

  menu.ui.io.scale = window::getDpiScaleFactor()/1.5
  menu.ui.pass(|menu| {
    background::drawBg({0, 0, 800, 600}, .advent, th::time/1000.0)
    ui.row(|menu| {
      ui.cellJustify(1.0)
      ui.col(|menu| {
        ui.cellColor(0xFFFFFFFF)
        ui.heading("SAVESCUM")
        ui.spring(1.0)
        ui.cellStretch()
        if ui.button("Play") {
          menu.setupGame()
        }
        ui.spring(0.1)
        ui.cellStretch()
        if ui.button("Editor"){
          menu.setupEditor()
        }
        ui.spring(1.0)
      }, window::h)
    }, 200).padding = 20
  })
}

fn (menu: ^MainMenu) destroy*() {
  if valid(menu.callbacks.destroyCb) {
    menu.callbacks.destroyCb()
  }
}
