import (
  "std.um"
  "th.um"
  "rect.um"
  "canvas.um"
  "font.um"

  "../misc/strings.um"
)

fn posTrans*(x, y: th::fu): th::Transform {
  return {p: {x, y}, s: {1, 1}}
}

fn readFileStr*(path: str): (str, std::Err) {
  file, err := std::fopen(path, "rb")

  if err.code != 0 {
    return "", err
  }

  s, err := std::freadall(file)

  return err.code == 0 ? strings::windows2unix(s) : "", err
}

fn writeFileStr*(path: str, dataStr: str): std::Err {
  file, err := std::fopen(path, "wb")
  if err.code != 0 {
    return err
  }

  std::fwrite(file, &[]char(dataStr))
  std::fclose(file)

  return {}
}

fn drawArrow*(p: th::Vf2, p1: th::Vf2, color: uint32) {
  canvas::drawLine(color, p, p1, 1)
  // draw arrowhead
  dir := p1.sub(p).norm()
  dir1 := dir.rotated({0, 0}, 45)
  dir2 := dir.rotated({0, 0}, -45)

  p2 := p1.sub(dir1.mulf(10))
  p3 := p1.sub(dir2.mulf(10))

  canvas::drawLine(color, p1, p2, 1)
  canvas::drawLine(color, p1, p3, 1)
}

fn drawArrow2*(p: th::Vf2, p1: th::Vf2, color: uint32) {
  canvas::drawLine(color, p, p1, 1)
  // draw arrowhead 1
  {
    dir := p1.sub(p).norm()
    dir1 := dir.rotated({0, 0}, 45)
    dir2 := dir.rotated({0, 0}, -45)

    p2 := p1.sub(dir1.mulf(10))
    p3 := p1.sub(dir2.mulf(10))

    canvas::drawLine(color, p1, p2, 1)
    canvas::drawLine(color, p1, p3, 1)
  }

  // draw arrowhead 2
  {
    dir := p.sub(p1).norm()
    dir1 := dir.rotated({0, 0}, 45)
    dir2 := dir.rotated({0, 0}, -45)

    p2 := p.sub(dir1.mulf(10))
    p3 := p.sub(dir2.mulf(10))

    canvas::drawLine(color, p, p2, 1)
    canvas::drawLine(color, p, p3, 1)
  }
}

// Returns rectangle shrinked by amount `by` from all left, right, top, bottom sides
fn rectShrink*(r: rect::Rect, by: real): rect::Rect {
  return {r.x+by, r.y+by, r.w-by*2, r.h-by*2}
}

// Pushes the child rect into the parent rect. 
// Won't work if child rectangle dimensions are bigger than parents rectangle. 
fn rectKeepInBounds*(child, parent: rect::Rect): rect::Rect {
  if child.x < parent.x {
    child.x = parent.x
  }
  if child.y < parent.y {
    child.y = parent.y
  }
  if (child.x+child.w) > (parent.x+parent.w) {
    child.x = parent.x+parent.w-child.w
  }
  if (child.y+child.h) > (parent.y+parent.h) {
    child.y = parent.y+parent.h-child.h
  }

  return child
} 

// Creates a split of rect `r` at `by` starting from the right side.
fn rectCutRight*(r: rect::Rect, by: real): rect::Rect {
  result := r
  result.x += r.w-by
  result.w = by
  return result
}

fn rectScale*(r: rect::Rect, by: real): rect::Rect {
  return {r.x*by, r.y*by, r.w*by, r.h*by}
}

fn min*(a, b: real): real {
  return a < b ? a : b
}

fn max*(a, b: real): real {
  return a > b ? a : b
}

fn clamp*(a, b, c: real): real {
  if a < b {
    return b
  }
  if a > c {
    return c
  }
  return a
}

fn isprint*(c: uint32): bool {
  // ASCII 0..31 (inclusive), are control characters
  // ASCII 127 is a control character (DEL)
  // we want to skip these 
  return c >= 32 && c != 127
}

fn wrapText*(font: ^font::Font, text: str, boundary: real): []str {
  result := []str{}
  lastIndex := 0
  shift := 0.0

  for i, chr in text {
    if (shift+font.measure(""+chr).x) > boundary {
      shift = 0
      result = append(result, slice(text, lastIndex, i))
      lastIndex = i
    }
    shift += font.measure(""+chr).x
  }
  result = append(result, slice(text, lastIndex))

  return result
}

fn formatMillis*(ms: int): str {
  s := ms / 1000
  m := s / 60
  h := m / 60
  s = s % 60
  m = m % 60
  if h > 0 {
    return sprintf("%d:%02d:%02d", h, m, s)
  } else if m > 0 {
    return sprintf("%d:%02d", m, s)
  } else if s > 0 {
    return sprintf("%ds", s)
  } 
  return sprintf("%dms", ms)
}

fn formatBytes*(bytes: int): str {
  if bytes < 1024 {
    return sprintf("%d B", bytes)
  }
  if bytes < 1024*1024 {
    return sprintf("%.2f KB", real(bytes)/1024)
  }
  if bytes < 1024*1024*1024 {
    return sprintf("%.2f MB", real(bytes)/(1024*1024))
  }
  return sprintf("%.2f GB", real(bytes)/(1024*1024*1024))
}


