// (C) skejeton

// WAR CRIME: THIS FILE IS A MESS.

import (
  "color.um"
  "window.um"
  "rect.um"
  "th.um"
  "image.um"
  "canvas.um"
  "input.um"
  "coll.um"

  "utf8.um"
  "std.um"


  "../ui/core.um"
  "../ui/atoms.um"
  "../ui/wm.um"
  "../ui/notification.um"
  "../ui/ui.um"
  "../ui/themer.um"
  "session.um"

  "../dbg/dbg.um"
  "../shared/shortcuts.um"
  "../misc/hashname.um"
  "../dbg/fps.um"
  "../game/world_data.um"
  "../shared/global.um"
  "../data/resources.um"
  "../gfx/background.um"
  "../game/world.um"
  "atlas.um"
  "../misc/util.um"
  "../misc/mouseinput.um"
  "../game/game.um"
  "../game/script.um"
  "../misc/immcursor.um"
  "../shared/payload_trigger.um"
  debug_info = "../dbg/info.um"
  render_debug_info = "../dbg/render.um"
  "../gfx/drawcmd.um"
  "../txt/buffer.um"
  "grid.um"

  "font.um"
  "../misc/strings.um"

  "../../umbox/os/os.um"
)

type (
  // HACK: Should editor handle the gameplay?
  EditorMode = enum {
    editor
    gameplay
  }

  ButtonState = struct {
    isOver: bool
    isDown: bool
    isPressed: bool
    isReleased: bool
  }
  
  WindowInfo = struct {
    contentRect: rect::Rect
    titlebarRect: rect::Rect
  }

  ScrollAreaInfo = struct {
    areaRect: rect::Rect
    contentRect: rect::Rect
  }

  EntityListAction = enum {
    none
    remove
    edit
    duplicate
    moveUp
    moveDown
  }

  EditorResources = struct {
    toolbarIcons: image::Image
    bevelImage: image::Image
    tilesetImage: image::Image
    superHotFire: image::Image
    glow: image::Image
    mainFont: font::Font
  }

  EditorEntities = struct {
    entitySelected: int
    list: []world_data::EntityDesc
  }

  Editor = struct {
    // Misc
    debugTimerStarted: bool
    debugTimerOrigin: int
    debugTimer: int
    showDebugInfo: bool
    showUiDebugInfo: bool
    dimDebugInfo: bool

    // Visual data
    resources: EditorResources

    // Editors
    tilemapGrid: grid::Grid
    tilesetGrid: grid::Grid
    tilemapLayer: int
    tilemapShowAllLayers: bool
    tileSelected: th::Vf2
    tileset: atlas::Atlas
    world: world::World
    isPlaying: bool
    isRelocatingPlayer: bool
    entityBypass: bool
    entities: EditorEntities
    potentialRoom: str // the room which is in the text box
    currentRoom: str
    dirty: bool
    mode: EditorMode

    // UI misc.
    currentWindow: str
    currentWindowLayer: int
    wm: wm::WM
    keepActive: bool

    // UI state
    uicore: ^core::Core
    ui: ^ui::UI
  }
) 

fn drawBevelRect(editor: ^Editor, r: rect::Rect, pushed: bool = false, color: uint32 = th::white) {
  if payload_trigger::aprilFools() {
    color = color::hsv(th::time/5000.0, 0.9, 1.0)
  }

  const (
    bevelOuterRect = rect::Rect{0, 0, 30, 30}
    bevelInnerRect = rect::Rect{5, 5, 20, 20}

    bevelPushedOuterRect = rect::Rect{30, 0, 30, 30}
    bevelPushedInnerRect = rect::Rect{5, 5, 20, 20}
  )

  if pushed {
    editor.uicore.ctx.drawNinepatch(editor.resources.bevelImage, bevelPushedOuterRect, bevelPushedInnerRect, r, color)
  } else {
    editor.uicore.ctx.drawNinepatch(editor.resources.bevelImage, bevelOuterRect, bevelInnerRect, r, color)
  }
}

fn centerTextWithinRect(font: font::Font, text: str, r: rect::Rect): th::Vf2 {
  sz := font.measure(text)

  return {(r.w-sz.x)/2+r.x, (r.h-sz.y)/2+r.y}
}

fn drawBtn(editor: ^Editor, text: str, r: rect::Rect, buttonState: ButtonState, revert: bool = false, color: uint32 = 0xFFFFFFFF) {
  if buttonState.isOver {
    immcursor::setCursor(.finger)
  }
  
  text = strings::splitBy(text, '#')[0]

  pushed := buttonState.isDown != revert

  colorMod := 0xFFFFFFFF
  if pushed {
    colorMod = 0xCCCCCCFF
  }

  drawBevelRect(editor, r, pushed, colorMod&color)
  editor.uicore.ctx.drawText(editor.resources.mainFont, text, centerTextWithinRect(editor.resources.mainFont, text, r), th::black)
}

fn drawButton(editor: ^Editor, r: rect::Rect, buttonState: ButtonState, revert: bool = false, color: uint32 = 0xFFFFFFFF) {
  pushed := buttonState.isDown != revert

  colorMod := 0xFFFFFFFF
  if pushed {
    colorMod = 0xCCCCCCFF
  }

  drawBevelRect(editor, r, pushed, colorMod&color)
}

fn drawButtonInactive(editor: ^Editor, r: rect::Rect, text: str, color: uint32 = 0x999999FF) {
  editor.uicore.beginTool(text, r)
  if (editor.uicore.isCurrentToolActive()) {
    immcursor::setCursor(.no)
  }
  events := editor.uicore.endTool()
  events.queryMouse(.left, mouseinput::pressed)
  text = strings::splitBy(text, '#')[0]
  editor.uicore.ctx.drawNinepatch(editor.resources.bevelImage, {60, 30, 30, 30}, {10, 10, 10, 10}, r, 0xFFFFFFFF)
  editor.uicore.ctx.drawText(editor.resources.mainFont, text, centerTextWithinRect(editor.resources.mainFont, text, r), 0x000000FF)
}

fn putButton(editor: ^Editor, r: rect::Rect, name: str): ButtonState {
  editor.uicore.beginTool(name, r)

  buttonState := ButtonState{}
  toolState := editor.uicore.getCurrentToolState()
  events := editor.uicore.endTool()

  if (toolState.active) {
    buttonState.isOver = true
    buttonState.isDown = events.queryMouse(.left, mouseinput::down) || events.queryMouse(.left, mouseinput::released)
    buttonState.isPressed = events.queryMouse(.left, mouseinput::pressed)
    buttonState.isReleased = events.queryMouse(.left, mouseinput::released) && toolState.hovered

    immcursor::setCursor(.finger)
  }

  return buttonState
}

fn putButtonBase(editor: ^Editor, r: rect::Rect, name: str, revert: bool = false, color: uint32 = 0xFFFFFFFF): ButtonState {
  bs := putButton(editor, r, name)
  drawButton(editor, r, bs, revert, color)
  return bs
}

fn uiBeginWindow(editor: ^Editor, title: str, r: rect::Rect, transparent: bool = false): (WindowInfo, bool) {
  const (
    padding = 0
    titlebarHeight = 30
  )

  var (
    contentRect: rect::Rect
    titlebarRect: rect::Rect
    movement: th::Vf2
  )

  windowRect := editor.wm.getWindowRect(title, r)^

  if windowRect.x >= global::screen.w-64 {
    windowRect.x = global::screen.w-64
  }

  if windowRect.x < -windowRect.w+32 {
    windowRect.x = -windowRect.w+32
  }

  if windowRect.y >= global::screen.h-32 {
    windowRect.y = global::screen.h-32
  }

  if windowRect.y < -10 {
    windowRect.y = -10
  }

  if (payload_trigger::aprilFools()) {
    windowRect.x += cos(th::time/100.0)
    windowRect.y += sin(th::time/100.0)
  }

  if !editor.wm.isWindowVisible(title) {
    // Prevent from getting pruned
    editor.uicore.freezeTool(title)

    return WindowInfo{}, false
  }
  if editor.currentWindow != "" {
    std::assert(false, "BeginWindow is called before EndWindow")
  }

  editor.currentWindow = title
  // FIXME: This is a hack around windows being able to change their layers mid drawing.
  //        Which would de-sync the results from getWindowLayer.
  editor.currentWindowLayer = editor.wm.getWindowLayer(title)

  position := th::Vf2{padding, padding}

  editor.uicore.ctx.moveLayer(1000*editor.currentWindowLayer)
  // Frame tool.
  editor.uicore.beginTool(title, windowRect)
  {
    if transparent {
      editor.uicore.ctx.drawNinepatch(editor.resources.bevelImage, {60, 0, 30, 30}, {10, 10, 10, 10}, util::rectShrink(windowRect, -5), 0xFFFFFFFF)
    } else {
      editor.uicore.ctx.drawNinepatch(editor.resources.bevelImage, {0, 0, 30, 30}, {10, 10, 10, 10}, util::rectShrink(windowRect, -5), 0xFFFFFFFF)
    }
    editor.uicore.ctx.drawNinepatch(editor.resources.glow, {0, 0, 48, 48}, {16, 16, 16, 16}, util::rectShrink(windowRect, -20), 0x000000FF)

    buttonSize := th::Vf2{titlebarHeight, titlebarHeight}
    buttonRect := rect::Rect{position.x+windowRect.x, position.y+windowRect.y, buttonSize.x, buttonSize.y}

    if !editor.wm.getWindowHideTitlebar(title) {
      if editor.ui.buttonOLD("#Close", buttonRect) {
        editor.wm.setWindowVisible(title, false)
      }

      //editor.uicore.ctx.drawRect(th::black, {position.x+windowRect.x+5, position.y+windowRect.y+titlebarHeight/2-2, buttonSize.x-10, 3})
      position.x += buttonSize.x + padding

      handleSize := th::Vf2{windowRect.w - position.x - padding, titlebarHeight}
      titlebarRect = {position.x+windowRect.x, position.y+windowRect.y, handleSize.x-1, handleSize.y}

      // Titlebar tool.
      {
        editor.uicore.beginTool("Titlebar", titlebarRect)
        events := editor.uicore.endTool()

        if (events.queryMouse(.left, mouseinput::pressed)) {
          editor.wm.putWindowOnFront(title)
        }
        if (events.queryMouse(.left, mouseinput::down)) {
          movement = events.mouseState.delta
        }
      }

      editor.uicore.ctx.drawImageRect(editor.resources.bevelImage, {0, 30, 29, 30}, titlebarRect)
      editor.uicore.ctx.beginScissorRect(titlebarRect)
        editor.uicore.ctx.drawText(editor.resources.mainFont, title, centerTextWithinRect(editor.resources.mainFont, title, titlebarRect), th::white)
        titlebarRect.x += 1
        editor.uicore.ctx.drawText(editor.resources.mainFont, title, centerTextWithinRect(editor.resources.mainFont, title, titlebarRect), th::white)
      editor.uicore.ctx.endScissor()

      position.x += handleSize.x + padding

      position.x = 0
      position.y += titlebarHeight
    }

    contentSize := th::Vf2{windowRect.w - position.x - padding, windowRect.h - position.y - padding}
    contentRect = {position.x+windowRect.x, position.y+windowRect.y, contentSize.x-1, contentSize.y-1}

    editor.uicore.beginTool("Body", contentRect)

    if editor.uicore.isCurrentToolHovered() && input::isJustPressed(.alt) {
      editor.wm.setWindowHideTitlebar(title, !editor.wm.getWindowHideTitlebar(title))
    }
  }

  if editor.uicore.mouseState.lmb.isDown {
    editor.wm.getWindowRect(title, windowRect) ^= editor.wm.getWindowRect(title, windowRect).shift(movement)
  } else {
    editor.wm.getWindowRect(title, windowRect) ^= windowRect.shift(movement)
  }

  return WindowInfo{contentRect: contentRect, titlebarRect: titlebarRect}, true
}

fn uiEndWindow(editor: ^Editor) {
  if editor.currentWindow == "" {
    std::assert(false, "EndWindow has no match with BeginWindow")
  }

  title := editor.currentWindow
  movement := th::Vf2{0, 0} // Same as movement but changes the window size
  squishing := th::Vf2{0, 0} // Same as movement but changes the window size
  windowRect := editor.wm.getWindowRect(title, {0, 0, 0, 0})

  // Finish ui tools.
  {
      events := editor.uicore.endTool()

      if (events.queryMouse(.left, mouseinput::pressed)) {
        editor.wm.putWindowOnFront(title)
      }
      if (events.queryMouse(.left, mouseinput::down)) {
        movement = events.mouseState.delta
      }

      gripSize := th::Vf2{15, 15}
      gripRect := rect::Rect{windowRect.x+windowRect.w-gripSize.x, windowRect.y+windowRect.h-gripSize.y, gripSize.x, gripSize.y}

      {
        editor.uicore.beginTool("Grip", gripRect)
        if editor.uicore.isCurrentToolActive() {
          immcursor::setCursor(.sizeNWSE)
        }
        events := editor.uicore.endTool()

        if events.queryMouse(.left, mouseinput::down) {
          squishing = editor.uicore.mouseState.delta
        }
      }

    editor.uicore.endTool()
  }
  editor.uicore.ctx.moveLayer(-1000*editor.currentWindowLayer)

  windowRect ^= windowRect.shift(movement)
  windowRect.w += squishing.x; windowRect.h += squishing.y
  // Clamp
  if windowRect.w < 100 {
    windowRect.w = 100
  }
  if windowRect.h < 100 {
    windowRect.h = 100
  }

  editor.currentWindow = ""
}

fn widgetWindow(editor: ^Editor, title: str, rect: rect::Rect, handler: fn (winfo: WindowInfo): void, transparent: bool = false) {
  if info, ok := uiBeginWindow(editor, title, rect, transparent); ok {
    handler(info)
    uiEndWindow(editor)
  }
}

type DrawGridRenderGuideCommand = struct {
  guide: grid::RenderGuide
  color: uint32
  thickness: real
}

fn (cmd: ^DrawGridRenderGuideCommand) draw(_: drawcmd::DrawProperties) {
  grid::drawRenderGuide(cmd.guide, cmd.color, cmd.thickness)
}

fn updateZoom(init: real, plus: real): th::Vf2 {
  zoom := util::clamp(init+(init*plus), 8, 128)

  return {zoom, zoom}
}

// Puts editor grid spanning the entire screen
// TODO: Fix scaling
fn putGrid(grid: ^grid::Grid, editor: ^Editor, rectangle: rect::Rect): th::Vf2 {
  grid.bb = rectangle

  editor.uicore.beginTool("Grid", rectangle)

  var highlightedTile: th::Vf2
  editor.uicore.ctx.beginScissorRect(rectangle)
  {
    editor.uicore.ctx.drawCustom(DrawGridRenderGuideCommand{grid::mkRenderGuideFromBoundingBox(grid^), 0xFFFFFF11, 1})
    highlightedTile = grid.toGrid(editor.uicore.mouseState.pos).floor()

    if editor.uicore.isCurrentToolActive() {
      p1, p2 := grid.toScreen(highlightedTile), grid.toScreen(highlightedTile.addf(1))
      editor.uicore.ctx.drawRect(0xFFFFFF33, {p1.x, p1.y, p2.x-p1.x, p2.y-p1.y})
      // Draw highlighted tile
    }

    coordinate := grid.toGridRel(rectangle.getDims().divf(2)).floor()
    coordinateString := sprintf("%+-4g %+-4g", coordinate.x, coordinate.y)

    bottomLeft := th::Vf2{rectangle.x, rectangle.y+rectangle.h}
    bottomLeft.y -= editor.resources.mainFont.measure(coordinateString).y
    editor.uicore.ctx.moveLayer(1)
    editor.uicore.ctx.drawText(editor.resources.mainFont, coordinateString, bottomLeft, th::white)
    editor.uicore.ctx.moveLayer(-1)
  }

  editor.uicore.ctx.endScissor()

  if editor.uicore.isCurrentToolActive() && input::isPressed(.space) {
    grid::gridPan(grid, editor.uicore.mouseState.delta)
  }

  events := editor.uicore.endTool()

  if events.queryMouse(.middle, mouseinput::down) {
    grid::gridPan(grid, editor.uicore.mouseState.delta)
  }

  scroll := events.queryScroll()
  if scroll != 0 {
    grid::gridZoomInto(grid, updateZoom(grid.s.x, scroll/10.0), events.mouseState.pos)
  }

  return highlightedTile
}

fn putIconButton(editor: ^Editor, name: str, r: rect::Rect, img: image::Image, revert: bool = false): ButtonState {
  bs := putButtonBase(editor, r, name, revert)
  pos := r.centerWithinRect({0, 0, 48, 48}).getPos()
  editor.uicore.ctx.drawImage(img, {p: pos, s: {1, 1}})
  return bs
}

fn putRadioButton(editor: ^Editor, r: rect::Rect, text: str, revert: bool = false): ButtonState {
  if revert {
    drawButtonInactive(editor, r, text)
  } else {
    bs := putButtonBase(editor, r, text, revert)
    editor.uicore.ctx.drawText(editor.resources.mainFont, text, centerTextWithinRect(editor.resources.mainFont, text, r), th::black)
    return bs
  }
  return ButtonState{}
}

fn insertInputTextIntoOneLineBuffer(buffer: ^buffer::Buffer, cursor: ^buffer::Cursor, text: str): bool {
  runes := utf8::decode(text)
  dirty := false

  for index, rune in runes {
    buffer.insert(cursor, rune.encode())
    dirty = true
  }

  return dirty
}

fn getFirstLineOfBuffer(buffer: ^buffer::Buffer): str {
  if len(buffer.lines) == 0 {
    return ""
  }

  return buffer.lines[0]
}

type SingleLineEdit = struct {
  scrollX: real
  buffer: buffer::Buffer
  cursor: buffer::Cursor
}

fn initSingleLineEdit(from: str): SingleLineEdit {
  buf :=  buffer::Buffer{lines: []str{from}}
  // NOTE: Maxout cursor
  cursor := buf.sanitizeCursor(buffer::Cursor{10000, 10000})

  return SingleLineEdit{0, buf, cursor}
}

fn initBufferFromString(s: str): buffer::Buffer {
  return buffer::Buffer{lines: []str{s}}
}

fn drawSingleLineEdit(editor: ^Editor, edit: ^SingleLineEdit, r: rect::Rect, drawCursor: bool) {

  editor.uicore.ctx.beginScissorRect(r)
  firstLine := getFirstLineOfBuffer(&edit.buffer)
  precursor := strings::uniSlice(firstLine, 0, edit.cursor.column)
  precursorMeasured := editor.resources.mainFont.measure(precursor)
  cursorRect := rect::Rect{precursorMeasured.x, 0, 1, precursorMeasured.y}

  // Make sure the cursor is visible on the screen
  // NOTE: Maybe I shouldn't modify the editor state while drawing eh?
  if (cursorRect.x+cursorRect.w) > (r.w-edit.scrollX) {
    edit.scrollX = -(cursorRect.x+cursorRect.w-r.w)
  }
  if cursorRect.x < -edit.scrollX {
    edit.scrollX = -cursorRect.x
  }

  if r.w > cursorRect.x {
    edit.scrollX = 0
  }

  cursorRect.x += r.x+edit.scrollX
  cursorRect.y += r.y

  if drawCursor {
    editor.uicore.ctx.drawRect(th::black, cursorRect)
  }
  editor.uicore.ctx.drawText(editor.resources.mainFont, firstLine, r.getPos().add(th::Vf2{edit.scrollX, 0}), th::black)
  editor.uicore.ctx.endScissor()
}

// @returns Is dirty
fn putTextEditOneLine(editor: ^Editor, r: rect::Rect, name: str, value: ^str): bool {
  dirty := false
  editor.uicore.beginTool(name, r)
    edit := ^SingleLineEdit(editor.uicore.getPropertyLazy("Editor", |value| { return initSingleLineEdit(value^) }))
    edit.buffer = initBufferFromString(value^)
    edit.cursor = edit.buffer.sanitizeCursor(edit.cursor)

    // Handle input.
    if (editor.uicore.isCurrentToolFocused()) {
      immcursor::setCursor(.iBeam)
      dirty = insertInputTextIntoOneLineBuffer(&edit.buffer, &edit.cursor, input::getStr())
      if input::isPressedRepeat(.backspace) {
        edit.buffer.erase(&edit.cursor)
        dirty = true
        input::clear(.backspace)
      }
      if input::isPressedRepeat(.delete) {
        cursorNext := edit.cursor
        cursorNext.column += 1
        if cursorNext.column <= len(edit.buffer.lines[0]) {
          cursorNext = edit.buffer.sanitizeCursor(cursorNext)
          edit.buffer.erase(&cursorNext)
        }
        dirty = true
        input::clear(.delete)
      }
      if input::isPressedRepeat(.left) {
        edit.cursor = edit.buffer.moveCursor(edit.cursor, -1, 0)
        input::clear(.left)
      }
      if input::isPressedRepeat(.right) {
        edit.cursor = edit.buffer.moveCursor(edit.cursor, 1, 0)
        input::clear(.right)
      }
    }

    // Draw.
    {
      drawBevelRect(editor, r, true)
      // Draw the inside white
      editor.uicore.ctx.drawRect(th::white, util::rectShrink(r, 2))

      fontHeight := editor.resources.mainFont.measure(" ").y
      textRect := rect::Rect{r.x+5, r.y+(r.h-fontHeight)/2.0, r.w-10, fontHeight}
      drawSingleLineEdit(editor, edit, textRect, editor.uicore.isCurrentToolFocused())
    }

    // Sync buffer up with the value.
    value ^= getFirstLineOfBuffer(&edit.buffer)
  editor.uicore.endTool()

  return dirty
}

fn beginScrollArea(editor: ^Editor, areaRect: rect::Rect, contentSize: th::Vf2): (bool, ScrollAreaInfo) {
  const (
    handleSize = 27
  )

  editor.uicore.ctx.drawNinepatch(editor.resources.bevelImage, {30*2, 0, 30, 30}, {10, 10, 10, 10}, areaRect, 0xFFFFFFFF)

  areaRect.x += 5
  areaRect.y += 5
  areaRect.w -= 10
  areaRect.h -= 10

  editor.uicore.beginTool("ScrollArea", areaRect)

  scroll := ^real(editor.uicore.getProperty("ScrollAreaScroll", 0.0))
  overflow := util::clamp(contentSize.y-areaRect.h, 0, contentSize.y)
  scrollValue := util::clamp(scroll^, 0, overflow)
  yScrollOverflowFactor := 0.0
  if areaRect.h != 0 {
    yScrollOverflowFactor = contentSize.y/areaRect.h
  }
  doNotTruncateScroll := false

  rightHandleRect := util::rectCutRight(areaRect, handleSize)
  editor.uicore.ctx.drawRect(0x777777FF, rightHandleRect)

  // If there's yknow, some overflow..
  if yScrollOverflowFactor > 1 {
    thumbHeight := rightHandleRect.h/yScrollOverflowFactor
    thumbGap := (rightHandleRect.h-thumbHeight)
    thumbOffset := thumbGap*(scrollValue/overflow)
    thumbRect := rightHandleRect
    thumbRect.h = thumbHeight
    thumbRect.y += thumbOffset

    if thumbRect.h < 10 {
      thumbRect.h = 10
    }

    thumbState := putButtonBase(editor, util::rectShrink(thumbRect, 1), "ScrollbarThumb")
    if thumbState.isDown {
      doNotTruncateScroll = true
      scroll ^+= editor.uicore.mouseState.delta.y*yScrollOverflowFactor
    }

  }

  if editor.showDebugInfo {
    // Show where the content ends.
    editor.uicore.ctx.moveLayer(1)
    editor.uicore.ctx.drawRect(th::magenta, {areaRect.x, areaRect.y+contentSize.y, contentSize.x, 1})
    editor.uicore.ctx.moveLayer(-1)
  }

  if !doNotTruncateScroll {
    // Clamp the scroll to the valid scroll range.
    scroll^ = util::clamp(scroll^, 0, overflow)
  }

  areaRect.w -= handleSize
  areaRect.w += 1 // Account for uneven padding between content and border
  contentRect := areaRect
  contentRect.w -= 1
  contentRect.y -= scrollValue


  return true, ScrollAreaInfo{areaRect: areaRect, contentRect: contentRect}
}

fn endScrollArea(editor: ^Editor) {
  scroll := ^real(editor.uicore.getProperty("ScrollAreaScroll", 0.0))

  events := editor.uicore.endTool()

  scroll ^-= events.queryScroll()*20.0
}

fn roomToPath(room: str): str {
  return "data/spiel/sc_"+room+".csv"
}

fn createEditorEntities(): EditorEntities {
  return EditorEntities{list: []world_data::EntityDesc{}, entitySelected: -1}
}


fn editorLoadRoom(editor: ^Editor, room: str): bool {
  dbg::logt("ed: loading world")
  if data, err := util::readFileStr(roomToPath(room)); err.code == 0 {
    worldData := world_data::load(editor.world, data)

    editor.world = worldData.world
    editor.entities.list = worldData.entities
    return true
  } else {
    // TODO(skejeton): maybe I shouldn't initialize empty world like that??!
    editor.world = world::fromTileset(editor.world.tileset)
    editor.entities = createEditorEntities()
  }
  return false
}

fn editorSaveRoom(editor: ^Editor) {
  dbg::logt("ed: saving world")
  err := util::writeFileStr(roomToPath(editor.currentRoom), world_data::save(world_data::WorldData{editor.world, editor.entities.list}))
  if err.code != 0 {
    dbg::logt("ed: save failed: "+err.msg)
    notification::put({.error, "Failed to save: "+err.msg})
  }
  editor.dirty = false
}

fn editorToggleGame(editor: ^Editor) {
  if (!editor.isPlaying) {
    editor.wm.setWindowVisible("Level Select", true)
    editor.debugTimerStarted = true
    editor.debugTimerOrigin = th::time
    editor.debugTimer = 0
    game::start(world_data::WorldData{editor.world, editor.entities.list})
    script::init()
  } else {
    editor.debugTimerStarted = false
    game::stop()
  }
  editor.isPlaying = !editor.isPlaying
}

fn putToolbarIconButton(editor: ^Editor, btnName: str, buttonRectangle: ^rect::Rect, ix, iy: int, revert: bool): bool {
  pressed := false
  editor.resources.toolbarIcons.crop(th::Vf2{ix/4.0, iy/4.0}, th::Vf2{(ix+1)/4.0, (iy+1)/4.0})
  if putIconButton(editor, btnName, buttonRectangle^, editor.resources.toolbarIcons, revert).isReleased {
    pressed = true
  }
  buttonRectangle.x += buttonRectangle.w

  return pressed
}

fn putToolbarWindowIconButton(editor: ^Editor, windowName: str, buttonRectangle: ^rect::Rect, ix, iy: int) {
  isVisible := editor.wm.isWindowVisible(windowName)
  if putToolbarIconButton(editor, windowName, buttonRectangle, ix, iy, isVisible) {
    editor.wm.putWindowOnFront(windowName)
    editor.wm.setWindowVisible(windowName, !isVisible)
  }
}

fn getEntitySelectedIndex(entities: ^EditorEntities): int {
  return entities.entitySelected
}

fn getEntitySelected(entities: ^EditorEntities): ^world_data::EntityDesc {
  if entities.entitySelected < 0 {
    return null
  }

  return &entities.list[entities.entitySelected]
}

// Puts window toolbar on the bottom of the screen
fn editorPutToolbar(editor: ^Editor) {
  const (
    margin = 0
    padding = 4
    rectangleHeight = 48 + margin * 2 + padding * 2
  )

  rectangle := rect::Rect{margin, global::screen.h - rectangleHeight + margin, global::screen.w - margin * 2, rectangleHeight - margin * 2}

  if payload_trigger::aprilFools() {
    x := 0
    y := rectangle.y - 48

    editor.resources.superHotFire.cropRect({0, (th::time/100%3)*32, 32, 32})

    for i := 0; i < global::screen.w/32+1; i++ {
      editor.uicore.ctx.drawImage(editor.resources.superHotFire, th::Transform{p: th::Vf2{x+i*32, y}, s: th::Vf2{1, 1}})
    }
  } 

  editor.uicore.beginTool("ToolBar", rectangle)
  {
    if !editor.isPlaying {
      editor.uicore.ctx.drawImageRect(editor.resources.bevelImage, {91, 30, 29, 30}, rectangle)
    }

    buttonRectangle := rect::Rect{rectangle.x+padding, rectangle.y+padding, rectangle.h-padding*2, rectangle.h-padding*2}

    if putToolbarIconButton(editor, "Play", &buttonRectangle, 1, 1, editor.isPlaying) {
      editorToggleGame(editor)
    }
    putToolbarWindowIconButton(editor, "Console (Aux)", &buttonRectangle, 1, 0)

    if !editor.isPlaying {
      putToolbarWindowIconButton(editor, "Load Room", &buttonRectangle, 2, 2)
      putToolbarWindowIconButton(editor, "Tile Picker", &buttonRectangle, 0, 1)
      putToolbarWindowIconButton(editor, "Player Placer", &buttonRectangle, 3, 1)
      putToolbarWindowIconButton(editor, "Entity List", &buttonRectangle, 0, 2)
      if getEntitySelected(&editor.entities) != null {
        putToolbarWindowIconButton(editor, "Entity Editor", &buttonRectangle, 1, 2)
      }

      // Draw Save/Load
      {
        position := rectangle.getEnd()
        position.y -= rectangle.h

        position.x -= 80
        if (editor.ui.buttonOLD("Save", {position.x-padding, position.y+padding, 80, rectangle.h-padding*2})) {
          editorSaveRoom(editor)
        }

        position.x -= 80
        if (editor.ui.buttonOLD("Load", {position.x-padding, position.y+padding, 80, rectangle.h-padding*2})) {
          editorLoadRoom(editor, editor.currentRoom)
        }
      }
    } else {
      putToolbarWindowIconButton(editor, "Level Select", &buttonRectangle, 3, 3)
    }
  }
  editor.uicore.endTool()
}

fn isAnyButtonHeld(mouseState: ^mouseinput::MouseState): bool {
  return mouseState.lmb.isDown || mouseState.mmb.isDown || mouseState.rmb.isDown
}

type WorldEditCmd = struct {
  showLayers: uint // 3 bits
  toolbarIcons: image::Image
  rect: rect::Rect
  grid: grid::Grid
  world: ^world::World
}

fn (d: ^WorldEditCmd) draw(props: drawcmd::DrawProperties) {
  const getcolor = fn (bit: bool): uint32 {
    if bit {
      return 0xFFFFFFFF
    }
    return 0xFFFFFF33
  }

  // background.draw(d.rect)
  canvas::drawRect(0x777777FF, global::screen)
  colors := []uint32{getcolor(d.showLayers&1>0), getcolor(d.showLayers&2>0), getcolor(d.showLayers&4>0)}

  offset := d.grid.toScreen(th::Vf2{0, 0})

  // TODO: 2D scaling?
  d.world.drawLayer(offset, -1, d.grid.s.x/32.0, colors[0])
  d.world.drawLayer(offset, 0, d.grid.s.x/32.0, colors[1])
  d.world.drawLayer(offset, 1, d.grid.s.x/32.0, colors[2])

  d.toolbarIcons.crop(th::Vf2{2.0/4.0, 0.0/4.0}, th::Vf2{3.0/4.0, 1.0/4.0})
  pos := d.grid.toScreen(d.world.playerSpawnPos)
  d.toolbarIcons.draw(th::Transform{p: th::Vf2{pos.x, pos.y}, s: d.grid.s.divf(48)})
}

fn getShownLayersBitmap(layerSelected: int, showAllLayers: bool): uint {
  return 1<<(layerSelected+1)|(int(showAllLayers)*0x7)
}

fn drawLayerIcon(ctx: ^drawcmd::DrawContext, position: th::Vf2, layer: int, showAllLayers: bool) {
  fills := [3]bool{layer == -1, layer == 0, layer == 1}

  // NOTE: If we choose to show all layers, the icon will show all boxes filled in
  if showAllLayers {
    fills = [3]bool{true, true, true}
  }

  position.x += 26*1.5

  for i, l in fills {
    rec := rect::Rect{position.x-30+3, position.y+3, 30, 18}
    position.x -= 3
    position.y += 6

    if l {
      ctx.drawRect(0xf0b5afFF, rec)
      ctx.drawRectLines(0xFFFFFFFF, rec)
    } else {
      ctx.drawRect(0x99a9a9a9, rec)
      ctx.drawRectLines(0xFFFFFFFF, rec)
    }
  }
}

type GameCmd = struct {}

fn (gc: ^GameCmd) draw(props: drawcmd::DrawProperties) {
  game::draw()
  script::draw()
}

fn putLabelY(editor: ^Editor, text: str, color: uint32, position: ^th::Vf2) {
  editor.uicore.ctx.drawText(editor.resources.mainFont, text, position^, color)
  position.y += editor.resources.mainFont.measure(text).y
}

fn putPlayerPlacer(editor: ^Editor) {
  widgetWindow(editor, "Player Placer", {5*1.5, 249*1.5, 160*1.5, 224*1.5}, |editor| {
    contentRect := util::rectShrink(winfo.contentRect, 5)
    position := contentRect.getPos()
    playerPos := editor.world.playerSpawnPos

    editor.uicore.ctx.beginScissorRect(contentRect)
    {
      putLabelY(editor, sprintf("x %d y %d", trunc(playerPos.x), trunc(playerPos.y)), th::black, &position)
      position.y += 10

      if editor.ui.buttonOLD("Relocate", {position.x, position.y, contentRect.w, 40}, editor.isRelocatingPlayer) {
        editor.isRelocatingPlayer = !editor.isRelocatingPlayer
      }
      position.y += 30+10

      if (editor.isRelocatingPlayer) {
        putLabelY(editor, "Click on the grid\nTo place player.", th::black, &position)
      }
    }
    editor.uicore.ctx.endScissor()
  })
}

fn putTilePicker(editor: ^Editor) {
  widgetWindow(editor, "Tile Picker", {5*1.5, 5*1.5, 160*1.5, 224*1.5}, |editor| {
    // NOTE: This is to cancel the window-body dragging thing.
    //       Probably not the best way to do it.
    contentRect := winfo.contentRect
    var selectedTile: th::Vf2

    editor.uicore.beginTool("Picker", contentRect)
    {
      editor.uicore.ctx.drawRect(0x222222FF, contentRect)
      editor.uicore.ctx.moveLayer(1)
      {
        imgDims := editor.tileset.i.getDims()
        newSelectedTile := putGrid(&editor.tilesetGrid, editor, contentRect)
        if !(newSelectedTile.x < 0 || newSelectedTile.y < 0 ||
           newSelectedTile.x >= imgDims.x/(imgDims.x/4) || newSelectedTile.y >= imgDims.y/(imgDims.x/4)) {
          selectedTile = newSelectedTile
        } else {
          selectedTile = editor.tileSelected
        }

        selectedTilePos := editor.tilesetGrid.toScreen(editor.tileSelected)

        editor.uicore.ctx.beginScissorRect(contentRect)
        editor.uicore.ctx.drawRectLines(color::alpha(th::green, 0.6), {selectedTilePos.x, selectedTilePos.y, editor.tilesetGrid.s.x, editor.tilesetGrid.s.y}, 1)
        editor.uicore.ctx.endScissor()
      }
      editor.uicore.ctx.moveLayer(-1)
      editor.uicore.ctx.beginScissorRect(contentRect)

      editor.tileset.i.crop(th::Vf2{0, 0}, th::Vf2{1, 1})
      editor.uicore.ctx.drawImage(editor.tileset.i, th::Transform{s: editor.tilesetGrid.s.divf(64), p: editor.tilesetGrid.toScreen(th::Vf2{0, 0})})
      editor.uicore.ctx.endScissor()
    }
    events := editor.uicore.endTool()

    if events.queryMouse(.left, mouseinput::down) {
      editor.tileSelected = selectedTile
    }
  })
}

fn putEntityEntry(editor: ^Editor, ent: world_data::EntityDesc, r: rect::Rect, selected: bool): EntityListAction {
  r.w -= 45*2
  action := EntityListAction.none

  editor.uicore.beginTool(ent.id, r)
  {
    if editor.ui.buttonOLD(ent.name, r) {
      action = .edit
    }
    if selected {
      editor.uicore.ctx.drawRectLines(th::white, util::rectShrink(r, 1))
      editor.uicore.ctx.moveLayer(1)
      editor.uicore.ctx.drawNinepatch(editor.resources.glow, {0, 0, 48, 48}, {16, 16, 16, 16}, util::rectShrink(r, -16), 0xFFFF00FF)
      editor.uicore.ctx.moveLayer(-1)
    }
    r.x += r.w
    r.w = 45
    r.h = 22.5
    if editor.ui.buttonOLD("▲", r) {
      action = .moveUp
    }
    r.y += 22.5
    if editor.ui.buttonOLD("▼", r) {
      action = .moveDown
    }
    r.y -= 22.5
    r.h = 45
    r.x += 45
    if input::isPressed(.shift) {
      if editor.ui.buttonOLD("␡", r) {
        action = .remove
      }
    } else {
      if editor.ui.buttonOLD("⎘", r) {
        action = .duplicate
      }
    }
  }
  editor.uicore.endTool()

  return action
}

fn appendEntity(editorEntities: ^EditorEntities, entity: world_data::EntityDesc) {
  editorEntities.list = append(editorEntities.list, entity)
}

fn removeEntity(editorEntities: ^EditorEntities, index: int) {
  // Unselect the entity
  if index == editorEntities.entitySelected {
    editorEntities.entitySelected = -1
  }
  // Shift the selected entity index down if entity below to be removed
  if index < editorEntities.entitySelected {
    editorEntities.entitySelected -= 1
  }
  editorEntities.list = delete(editorEntities.list, index)
}

fn findEntity(entities: []world_data::EntityDesc, id: str): bool {
  for i, entity in entities {
    if entity.id == id {
      return true
    }
  }
  return false
}

fn allocateEntityId(entities: []world_data::EntityDesc): str {
  id := hashname::random()
  for findEntity(entities, id) {
    dbg::logt("allocateEntityId: regenerating id!!")
    id = hashname::random()
  }
  return id
}

fn makeRandomEntity(id: str): world_data::EntityDesc {
  return world_data::EntityDesc{name: id, id: id, tags: ""}
}

fn selectEntity(entities: ^EditorEntities, index: int) {
  entities.entitySelected = index
}

fn isEntitySelected(entities: ^EditorEntities, index: int): bool {
  return entities.entitySelected == index
}

fn initEntityAtCenter(editor: ^Editor, ent: world_data::EntityDesc): world_data::EntityDesc {
  ent.rect = rect::Rect{-editor.tilemapGrid.p.x*32-16, -editor.tilemapGrid.p.y*32-16, 32, 32}
  return ent
}

fn cloneEntity(entities: []world_data::EntityDesc, ent: world_data::EntityDesc): world_data::EntityDesc {
  ent.id = allocateEntityId(entities)
  return ent
}

fn doEntityAction(editor: ^Editor, action: EntityListAction, i: int) {
  entryRemoveIndex := -1
  moveFrom := -1
  moveTo := -1

  pmoveFrom := &moveFrom
  pmoveTo := &moveTo
  pentryRemoveIndex := &entryRemoveIndex

  switch action {
    case .moveUp:
      pmoveFrom ^= i
      pmoveTo ^= i-1
      editor.dirty = true
    case .moveDown:
      pmoveFrom ^= i
      pmoveTo ^= i+1
      editor.dirty = true
    case .remove:
      pentryRemoveIndex ^= i
      editor.dirty = true
    case .edit:
      selectEntity(&editor.entities, i)
      editor.wm.setWindowVisible("Entity Editor", true)
      editor.wm.putWindowOnFront("Entity Editor")
    case .duplicate:
      appendEntity(&editor.entities, cloneEntity(editor.entities.list, editor.entities.list[i]))
      pmoveFrom ^= len(editor.entities.list)-1
      pmoveTo ^= i+1
      selectEntity(&editor.entities, pmoveFrom^)
      editor.dirty = true
  }

  if moveFrom != -1 && moveTo != -1 && moveFrom < len(editor.entities.list) && moveTo < len(editor.entities.list) {
    if getEntitySelectedIndex(&editor.entities) == moveFrom {
      selectEntity(&editor.entities, moveTo)
    }

    ent := editor.entities.list[moveFrom]
    editor.entities.list[moveFrom] = editor.entities.list[moveTo]
    editor.entities.list[moveTo] = ent
  }

  if entryRemoveIndex != -1 {
    removeEntity(&editor.entities, entryRemoveIndex)
    editor.dirty = true
  }
}

fn putEntityList(editor: ^Editor) {
  _actions := map[int]EntityListAction{}
  actions := &_actions

  widgetWindow(editor, "Entity List", {595*1.5, 5*1.5, 200*1.5, 300*1.5}, |editor, actions| {
    // Apply padding.
    contentRect := util::rectShrink(winfo.contentRect, 5)

    // Put add button.
    {
      buttonRect := util::rectCutRight(winfo.titlebarRect, winfo.titlebarRect.h)

      if editor.ui.buttonOLD("+", buttonRect) {
        appendEntity(&editor.entities, initEntityAtCenter(editor, makeRandomEntity(allocateEntityId(editor.entities.list))))
        selectEntity(&editor.entities, len(editor.entities.list)-1)
      }
    }

    // Put entries.
    {
      // Get content size.
      contentSize := ^th::Vf2(editor.uicore.getProperty("ContentSize", th::Vf2{0, 0}))

      if ok, scrollAreaInfo := beginScrollArea(editor, contentRect, contentSize^); ok {
        editor.uicore.ctx.beginScissorRect(scrollAreaInfo.areaRect)
        entryRect := scrollAreaInfo.contentRect
        entryRect.h = 45
        for i, ent in editor.entities.list {
          if entryRect.y < scrollAreaInfo.areaRect.y-45 || entryRect.y > scrollAreaInfo.areaRect.y+scrollAreaInfo.areaRect.h {
            entryRect.y += 45
            continue
          }
          action := putEntityEntry(editor, ent, entryRect, isEntitySelected(&editor.entities, i))
          if action != .none {
            actions[i] = action
          }
          entryRect.y += 45
        }

        contentSize ^= th::Vf2{entryRect.w, entryRect.y-scrollAreaInfo.contentRect.y}
        editor.uicore.ctx.endScissor()
        endScrollArea(editor)
      }
    }
  })

  // For now, only one action can be applied at a time, due to indexing.
  std::assert(len(_actions) < 2)

  // Apply actions.
  for i, action in actions {
    doEntityAction(editor, action, i)
  }
}

fn putEntityEditor(editor: ^Editor) {
  entitySelected := getEntitySelected(&editor.entities)

  if entitySelected != null {
    widgetWindow(editor, "Entity Editor", {595, 210, 300, 330}, |editor, entitySelected| {
      contentRect := util::rectShrink(winfo.contentRect, 5)

      editor.uicore.ctx.beginScissorRect(contentRect)
      position := contentRect.getPos()
      putLabelY(editor, "Name", th::black, &position)
      editor.dirty = putTextEditOneLine(editor, {position.x, position.y, contentRect.w, 46}, "Name", &entitySelected.name) || editor.dirty
      position.y += 46
      putLabelY(editor, "Id", th::black, &position)
      editor.dirty = putTextEditOneLine(editor, {position.x, position.y, contentRect.w, 46}, "Id", &entitySelected.id) || editor.dirty
      position.y += 46
      putLabelY(editor, "Tags", th::black, &position)
      editor.dirty = putTextEditOneLine(editor, {position.x, position.y, contentRect.w, 46}, "Tags", &entitySelected.tags) || editor.dirty
      position.y += 46
      position.y += 10
      if editor.ui.buttonOLD("Delete", {position.x, position.y, contentRect.w, 40}) {
        removeEntity(&editor.entities, getEntitySelectedIndex(&editor.entities))
        editor.dirty = true
      }
      editor.uicore.ctx.endScissor()
    })
  }
}

type RectResizeCommand = struct {
  posFactor: th::Vf2   // Factor to multiply MouseDelta by to move the rectangle
  sizeFactor: th::Vf2  // Factor to multiply MouseDelta by to resize the rectangle
}

type EditGrip = struct {
  position: th::Vf2
  resizeCommand: RectResizeCommand
}

fn putRectGrips(editor: ^Editor, r: rect::Rect): RectResizeCommand {
  // Grips positions are initialized as relative here.
  // Will be multiplied by rect.w/h and added rect.x/y to them.
  const eightGrips = []EditGrip{
    {{0.0, 0.0}, {{1, 1}, {-1, -1}}}, // x
    {{0.5, 0.0}, {{0, 1}, { 0, -1}}}, // x
    {{1.0, 0.0}, {{0, 1}, { 1, -1}}}, // x

    {{0.0, 0.5}, {{1, 0}, {-1,  0}}},
    {{1.0, 0.5}, {{0, 0}, { 1,  0}}},

    {{0.0, 1.0}, {{1, 0}, {-1,  1}}}, // x
    {{0.5, 1.0}, {{0, 0}, { 0,  1}}}, // x
    {{1.0, 1.0}, {{0, 0}, { 1,  1}}}  // x
  }

  activeGrip := -1

  for i, grip in eightGrips {
    gripPos := r.getDims().mul(grip.position).add(r.getPos())
    gripRect := rect::Rect{gripPos.x-6, gripPos.y-6, 12, 12}
    gripDrawRect := util::rectShrink(gripRect, 2)

    editor.uicore.beginTool(sprintf("Grip%d", i), gripRect)

    if editor.uicore.isCurrentToolActive() {
      cursor := window::Cursor.sizeAll
      switch i {
      case 0, 7: cursor = .sizeNWSE
      case 2, 5: cursor = .sizeSWNE
      case 1, 6: cursor = .sizeNS
      case 3, 4: cursor = .sizeEW
      }
      immcursor::setCursor(cursor)
    }

    color := th::blue

    if editor.uicore.isCurrentToolActive() {
      color = th::cyan
    }

    editor.uicore.ctx.drawRect(color, gripDrawRect)
    editor.uicore.ctx.drawRectLines(th::black, gripDrawRect)

    events := editor.uicore.endTool()

    if events.queryMouse(.left, mouseinput::down) {
      activeGrip = i
    }
  }

  if activeGrip == -1 {
    return RectResizeCommand{}
  }

  return eightGrips[activeGrip].resizeCommand
}

fn applyRectResizeCommand(resizeCommand: RectResizeCommand, r: rect::Rect, delta: th::Vf2): rect::Rect {
  r.x += delta.x * resizeCommand.posFactor.x
  r.y += delta.y * resizeCommand.posFactor.y
  r.w += delta.x * resizeCommand.sizeFactor.x
  r.h += delta.y * resizeCommand.sizeFactor.y
  return r
}

type DrawEntityCmd = struct {
  entity: world_data::EntityDesc
  r: rect::Rect
  tags: ^game::TagSet
  scale: real
}

fn (cmd: ^DrawEntityCmd) draw(props: drawcmd::DrawProperties) {
  if !game::drawEntityObject(cmd.entity.name, cmd.tags, cmd.r, cmd.scale) {
    canvas::drawRect(th::red, cmd.r)
  }
}

fn drawTaggedEntityRect(editor: ^Editor, entity: ^world_data::EntityDesc, r: rect::Rect, tags: ^game::TagSet) {
  if tags.isSet("Guide") {
    editor.uicore.ctx.drawRectLines(th::yellow, r)
  } else if tags.isSet("Comment") {
    size := editor.resources.mainFont.measure(entity.name)
    entity.rect.w = size.x
    entity.rect.h = size.y
    editor.uicore.ctx.drawText(editor.resources.mainFont, entity.name, th::Vf2{r.x, r.y}, th::white, editor.tilemapGrid.s.x/32)
  } else {
    editor.uicore.ctx.drawCustom(DrawEntityCmd{entity^, r, tags, editor.tilemapGrid.s.x/32})
  }
}

fn adjustEntityRect(editor: ^Editor, tags: ^game::TagSet, ent: ^world_data::EntityDesc): rect::Rect {
  r := ent.rect

  if r.w < 10 {
    r.w = 10
  }
  if r.h < 10 {
    r.h = 10
  }

  if tags.isSet("Comment") {
    size := editor.resources.mainFont.measure(ent.name)
    r.w = size.x
    r.h = size.y
  }

  return r
}

fn putWorldEntities(editor: ^Editor) {
  for i in editor.entities.list {
    ent := &editor.entities.list[i]

    entVisRect := util::rectScale(ent.rect, editor.tilemapGrid.s.x/32).shift(editor.tilemapGrid.toScreen(th::Vf2{0, 0}))

    if !coll::rectToRect(entVisRect, {0, 0, global::screen.w, global::screen.h}) {
      continue
    }

    // FIXME: Initializing tag set every time we render an entity is not efficient at all.
    tags_ := game::initTagSetFromString(ent.tags)
    tags := new(game::TagSet, tags_)
    ignore := tags.isSet("Guide") && editor.entityBypass && !isEntitySelected(&editor.entities, i)

    drawTaggedEntityRect(editor, ent, entVisRect, tags)

    if !ignore {
      editor.uicore.beginTool("Ent"+ent.id, entVisRect)

      if editor.uicore.isCurrentToolActive() {
        immcursor::setCursor(.sizeAll)
      }

      if editor.uicore.isCurrentToolFocused() {
        editor.uicore.ctx.drawRectLines(th::blue, util::rectShrink(entVisRect, -1))
      } else if editor.uicore.isCurrentToolActive() {
        editor.uicore.ctx.drawRectLines(th::yellow, util::rectShrink(entVisRect, -1))
      }

      if isEntitySelected(&editor.entities, i) {
        if editor.uicore.isCurrentToolFocused() {
          dx, dy := 0, 0
          if input::isPressedRepeat(.up) {
            dy += -1
            input::clear(.up)
          }
          if input::isPressedRepeat(.down) {
            dy += 1
            input::clear(.down)
          }
          if input::isPressedRepeat(.right) {
            dx += 1
            input::clear(.right)
          }
          if input::isPressedRepeat(.left) {
            dx += -1
            input::clear(.left)
          }
          if input::isPressed(.alt) {
            if dx != 0 {
              ent.rect.w += dx*32
              ent.rect.w = 32*round(ent.rect.w/32)
              editor.dirty = true
            }
            if dy != 0 {
              ent.rect.h += dy*32
              ent.rect.h = 32*round(ent.rect.h/32)
              editor.dirty = true
            }
          } else {
            if dx != 0 {
              ent.rect.x += dx*32
              ent.rect.x = 32*round(ent.rect.x/32)
              editor.dirty = true
            }
            if dy != 0 {
              ent.rect.y += dy*32
              ent.rect.y = 32*round(ent.rect.y/32)
              editor.dirty = true
            }
          }
        }

        editor.uicore.ctx.drawRectLines(th::yellow, util::rectShrink(entVisRect, 0))

        rectCmd := putRectGrips(editor, entVisRect)
        delta := editor.uicore.mouseState.delta.div(editor.tilemapGrid.s).mulf(32)

        ent.rect = applyRectResizeCommand(rectCmd, ent.rect, delta)

        adjusted := adjustEntityRect(editor, tags, ent)
        sizeD := adjusted.getDims().sub(ent.rect.getDims())
        ent.rect = adjusted

        ent.rect.x -= rectCmd.posFactor.x*sizeD.x
        ent.rect.y -= rectCmd.posFactor.y*sizeD.y
      }

      events := editor.uicore.endTool()

      if events.queryMouse(.left, mouseinput::pressed) {
        selectEntity(&editor.entities, i)
        editor.wm.setWindowVisible("Entity Editor", true)
        editor.wm.putWindowOnFront("Entity Editor")
      }
      if events.queryMouse(.left, mouseinput::down) {
        ent.rect.x += events.mouseState.delta.x/editor.tilemapGrid.s.x*32
        ent.rect.y += events.mouseState.delta.y/editor.tilemapGrid.s.y*32
        editor.dirty = true
      }
    }
  }
}

fn deselectEntity(entities: ^EditorEntities) {
  entities.entitySelected = -1
}

fn loadRoom(editor: ^Editor, room: str) {
  editor.currentRoom = room
  editor.potentialRoom = room
  editorLoadRoom(editor, room)
  editor.tilemapGrid.p = editor.world.playerSpawnPos
}

fn putRoomEditor(editor: ^Editor) {
  widgetWindow(editor, "Load Room", {180*1.5, 5*1.5, 200*1.5, 100*1.5}, |editor| {
    contentRect := util::rectShrink(winfo.contentRect, 5)
    position := contentRect.getPos()

    putTextEditOneLine(editor, {position.x, position.y, contentRect.w, 40}, "Room name", &editor.potentialRoom)

    position.y += 50
    if input::isPressed(.shift) {
      if editor.ui.buttonOLD("Load", {position.x, position.y, contentRect.w, 40}) {
        loadRoom(editor, editor.potentialRoom)
      }
    } else {
      drawButtonInactive(editor, {position.x, position.y, contentRect.w, 40}, "Hold shift!")
    }
  })
}

fn putNotifications(editor: ^Editor) {
  ns := notification::get()

  y := 0.0
  for i in ns {
    n := ns[len(ns^)-i-1]
    t := 1-util::clamp(n.time, 0, 1)
    ts := editor.resources.mainFont.measure(n.info.message)
    w := ts.x+30+20
    h := ts.y + 20
    y -= h

    editor.resources.toolbarIcons.cropRect({24*int(n.info.icon), 144, 24, 24})
    drawBevelRect(editor, {10-t*500, global::screen.h-58+y, w, h}, true, 0xFFFFFFBB)
    editor.uicore.ctx.drawImage(editor.resources.toolbarIcons, th::Transform{p: th::Vf2{10-t*500+10, global::screen.h-58+y+10}, s: th::Vf2{1, 1}})
    editor.uicore.ctx.drawText(editor.resources.mainFont, n.info.message, {50-t*500, global::screen.h-58+y+9}, th::black)
    y -= 10
  }
}

fn putLevelSelect(editor: ^Editor) {
  widgetWindow(editor, "Level Select", {0, 0, 300, 450}, |editor| {
    contentRect := util::rectShrink(winfo.contentRect, 5)

    type Level = struct { id, name: str }

    levels := []Level{}

    for i, ent in editor.entities.list {
      if strings::startsWith(ent.id, "stage") {
        levels = append(levels, Level{ent.id, ent.name})
      }
    }

    sort(levels, true, id)
    
    contentSize := ^th::Vf2(editor.uicore.getProperty("ContentSize", th::Vf2{0, 0}))
    if ok, scrollAreaInfo := beginScrollArea(editor, contentRect, contentSize^); ok {
      editor.uicore.ctx.beginScissorRect(scrollAreaInfo.areaRect)
      position := scrollAreaInfo.contentRect.getPos()
      y := 0.0

      for i, level in levels {
        p := th::Vf2{position.x+(i%2)*((contentRect.w-30)/2), position.y+(i/2)*45}
        if editor.ui.buttonOLD(level.name, {p.x, p.y, (contentRect.w-30)/2, 45}) {
          game::tele(level.id)
        }
        y = p.y-position.y+45.0
      }

      contentSize ^= th::Vf2{contentRect.w, y}

      editor.uicore.ctx.endScissor()
      endScrollArea(editor)
    }
  })
}

type Window* = struct {
  visible: bool
  title: str
  rect: rect::Rect
}

var windows: map[str]Window

fn toggleWindow(title: str, rect: rect::Rect) {
  if !validkey(windows, title) {
    w := &windows[title]
    w ^= {
      visible: !w.visible,
      title: title,
      rect: rect
    }
  }
}

fn (w: ^Window) display(ui: ^ui::UI) {
  //ui.cellRect(w.rect, |w| {
  //  ui.boxStyle(.window)
  //})
}

fn (editor: ^Editor) putToolbar(ui: ^ui::UI) {
  ui.row(|editor| {
    ui.boxStyle(.toolbar)

    windowBtn := fn (name: str, rect: rect::Rect) |ui, editor| {
      if ui.button2(name, |editor, rect| {ui.img2(editor.resources.toolbarIcons, rect)}) {
        toggleWindow(name, {300, 600, 100, 200})
      }
    }

    windowBtn("Play", {48, 48, 48, 48})
    windowBtn("Console", {48, 0, 48, 48})
    windowBtn("Load Room", {48*2, 48*2, 48, 48}) 
    windowBtn("Tile Picker", {48*0, 48, 48, 48}) 
    windowBtn("Player Placer", {48*3, 48, 48, 48}) 
    windowBtn("Entity List", {48*0, 48*2, 48, 48})
    ui.spring(0.5)
    ui.button("Load")
    ui.button("Save")
  }, window::w).padding = 4


  for _, w in windows {
    w.display(ui)
  }
}

fn (editor: ^Editor) putUi(ui: ^ui::UI) {
  ui.col(|editor| {
    ui.spring(1)
    ui.row(|editor| {
      editor.putToolbar(ui)
    }, window::w)
  }, window::h)
}

fn editorSaveSession(editor: ^Editor): session::Session {
  session := session::Session{}
  session.pan = editor.tilemapGrid.p
  session.scale = editor.tilemapGrid.s.x
  session.room = editor.currentRoom
  session.allLayers = editor.tilemapShowAllLayers
  session.entityBypass = editor.entityBypass
  session.layerSelected = editor.tilemapLayer
  session.tileSelected  = editor.tileSelected
  session.showUiDebug = editor.showUiDebugInfo
  session.plainBiscuit = global::plainBiscuit

  for name, win in editor.wm.windows {
    isVisible := editor.wm.windowVisibility[name]

    session.windows = append(session.windows, session::Window{name, isVisible, win.rect})
  }

  return session
}

fn editorLoadSession(editor: ^Editor, session: session::Session) {
  loadRoom(editor, session.room)
  editor.tilemapGrid.p = session.pan
  editor.tilemapGrid.s.x = session.scale
  editor.tilemapGrid.s.y = session.scale
  editor.tilemapShowAllLayers = session.allLayers
  editor.entityBypass = session.entityBypass
  editor.tilemapLayer = session.layerSelected
  editor.tileSelected = session.tileSelected
  editor.showUiDebugInfo = session.showUiDebug
  global::plainBiscuit = session.plainBiscuit

  for i, win in session.windows {
    editor.wm.setWindowVisible(win.name, win.visible)
    editor.wm.getWindowRect(win.name, win.rect)
  }
}

fn (editor: ^Editor) handleShortcuts*() {
  if input::isPressed(.ctrl) {
    if input::isJustPressedc('s') {
      input::clearc('s')
      editorSaveRoom(editor)
    }
    if input::isJustPressedc('q') {
      input::clearc('q')
      for w in editor.wm.windows {
        editor.wm.setWindowVisible(w, false)
      }
    }
    if input::isJustPressedc('d') {
      input::clearc('d')
      idx := getEntitySelectedIndex(&editor.entities)
      if idx != -1 {
        doEntityAction(editor, .duplicate, idx)
      }
    }
  }
  if input::isJustPressed(.fn25) {
    std::assert(false, "The F25 key? What's that?")
  }
  if input::isJustPressed(.pause) {
    editorToggleGame(editor)
  }
  if input::isJustPressed(.fn6) {
    editor.debugTimerStarted = !editor.debugTimerStarted
    if editor.debugTimerStarted {
      editor.debugTimerOrigin = th::time
      editor.debugTimer = 0
    }
  }
  if input::isJustPressed(.fn5) {
    editorToggleGame(editor)
  }
  if input::isJustPressed(.fn4) {
    editor.showUiDebugInfo = !editor.showUiDebugInfo
  }
  if input::isJustPressed(.fn3) {
    editor.showDebugInfo = !editor.showDebugInfo
  }
  if input::isJustPressed(.fn2) {
    global::plainBiscuit = !global::plainBiscuit
  }
  if input::isJustPressed(.fn1) {
    dbg::logt("dfjslfkjsd")
    notification::put({.warning, sprintf("Hello, world! %d", th::time)})
  }
}

fn setup*() {
  global::screen = {0, 0, 1200, 900}
  window::setup("Editor", trunc(global::screen.w), trunc(global::screen.h))
}

fn mk*(rl: ^resources::ResourceLoader): ^Editor {
  // HACK: This shouldn't be handled in the editor.
  background::init(rl)
  game::init(rl)

  resources := EditorResources {
    bevelImage: resources::loadImage(rl, "data/img/ui/1_5x/base.png", .linear),
    tilesetImage: resources::loadImage(rl, "data/img/ts_sky.png", .linear),
    toolbarIcons: resources::loadImage(rl, "data/img/ui/1_5x/icons.png", .linear),
    superHotFire: resources::loadImage(rl, "data/img/SUPER HOT FIRE WTF.png", .linear),
    glow: resources::loadImage(rl, "data/img/ui/1_0x/glow.png", .nearest),
    mainFont: resources::loadFont(rl, "data/font/FairfaxHD.ttf", 24, .linear)
  }

  tileset := atlas::mk(resources.tilesetImage, {4, 9})
  ui := new(ui::UI, ui::mk())

  editor := &Editor{
    mode: .editor,
    ui: ui,
    uicore: new(core::Core, core::mk()),
    tilemapGrid: grid::Grid{s: {48, 48}},
    tilesetGrid: grid::Grid{s: {48, 48}},
    tilemapShowAllLayers: false,
    entityBypass: true,
    tileset: tileset,
    world: world::fromTileset(tileset),
    resources: resources,
    entities: createEditorEntities(),
    wm: wm::create()
  }

  editor.ui.setBoxTheme(.button, {
    normal: themer::mkNinepatch(resources.bevelImage, {0, 0, 30, 30}, {4, 4, 21, 21}),
    pressed: themer::mkNinepatch(resources.bevelImage, {30, 0, 30, 30}, {4, 4, 21, 21})
  })
  editor.ui.setBoxCursor(.button, .finger)
  editor.ui.setBoxTheme(.toolbar, {
    normal: themer::mkNinepatch(resources.bevelImage, {90, 30, 30, 30}, {4, 4, 21, 21})
  })

  // TODO: Should we handle the session loading here really?
  if sessionFile, err := util::readFileStr(th::convPath("data://SAVESCUM/session.json")); err.code == 0 {
    editorLoadSession(editor, session::load(sessionFile))
  } else {
    loadRoom(editor, "testarea")
  }

  return editor
}

fn (editor: ^Editor) update*(mode: EditorMode) {
  if mode == .gameplay && !editor.isPlaying {
    editorToggleGame(editor)
  }

  // Subsystem updates
  notification::update()
  fps::update()
  payload_trigger::update()
  immcursor::setCursor(.system)
  editor.handleShortcuts()

  if editor.debugTimerStarted {
    editor.debugTimer = th::time-editor.debugTimerOrigin
  }
  
  std::srand(std::time())
  shortcuts::console(&editor.wm)
  shortcuts::fullscreen()

  global::screen = rect::Rect{0, 0, window::w, window::h}
  window::setViewport(global::screen.getDims())

  editor.ui.font = editor.resources.mainFont

  editor.ui.pass(|editor| {
    editor.putUi(ui)
  }, editor.showUiDebugInfo)

  fpsNode := debug_info::Display{ "FPS", fps::getFps(), false }
  if payload_trigger::aprilFools() {
    fpsNode = debug_info::Display{ "SPF", 1/fps::getFps(), false }
  }

  if editor.showDebugInfo {
    editor.dimDebugInfo = render_debug_info::renderDebugInfo(editor.resources.mainFont, {
      displays: {
        fpsNode,
        { "TPS", 1000.0/game::updateStepMs, false },
        { "Room", editor.currentRoom, false },
        { "Frameskip", trunc(game::frameSkips), false },
        { "Dirty?", editor.dirty, false },
        { "Version", global::version, false },
        { "Scale", editor.tilemapGrid.s, false },
        { "Plain", global::plainBiscuit, false },
        { "Playthrough (ms)", editor.debugTimer, false },
        { "Playthrough Started", editor.debugTimerStarted, false },
        { "Memory usage", util::formatBytes(memusage()), false }
      }
    }, editor.dimDebugInfo)
  }
}

fn (editor: ^Editor) destroy*() {
  // HACK: Should the session managment be handled here?
  if !os::isdir(th::convPath("data://SAVESCUM")) {
    os::mkdir(th::convPath("data://SAVESCUM"))
  }

  err := util::writeFileStr(th::convPath("data://SAVESCUM/session.json"), session::save(editorSaveSession(editor)))
  if err.code != 0 {
    dbg::logt("Failed to save session!")
  }
  atoms::disconnectAllNodes(editor.uicore.tools)
}
