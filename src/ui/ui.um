// Main UI controller

import (
  "std.um"
  "canvas.um"
  "rect.um"
  "th.um"
  "input.um"
  "coll.um"
  "font.um"
  "image.um"
  "color.um"
  "../misc/util.um"
  "../misc/fnv1.um"
)

type (
  RenderFn* = fn(ui: ^UI, r: rect::Rect, el: ^El)

  LayoutType* = enum {
    col
    row
    spring
    screen
  }

  RenderCall* = struct {
    r: rect::Rect
    el: ^El
  }

  El* = struct {
    parent: weak ^El
    sizeOverride: real
    justify: real
    rect: rect::Rect
    children: []El
    layout: LayoutType
    pos: th::Vf2
    label: bool
    id: uint
    padding: real
    crop: rect::Rect
    size: th::Vf2
    img: image::Image
    text: str
  }

  Retained* = struct {
    life: int
    id: any
    rect: rect::Rect
  }

  UI* = struct {
    uniq: uint
    font: font::Font
    retained: map[uint]Retained
    ids: []uint
    parents: []^El
    root: ^El
  }
)

fn mk*(): UI {
  return {font: canvas::pixelFont}
}

fn (ui: ^UI) layout(node: ^El, x, y: real): th::Vf2 {
  if node == null {
    return {}
  }

  sx, sy := 0.0, 0.0
  x += node.padding
  y += node.padding
  initX, initY := x, y

  springTotal := 0.0

  for i, child^ in node.children {
    springTotal += child.justify

    if child.justify != 0 {
      continue
    }

    if node.layout == .row {
      sz := ui.layout(child, x+sx, y)
      if child.layout == .screen {
        continue
      }
      r := rect::Rect{x+sx, y, sz.x, sz.y}
      ui.retained[child.id].rect = r
      child.rect = r
      sx += r.w
      sy = sy > r.h ? sy : r.h
    } else if node.layout == .col {
      sz := ui.layout(child, x, y+sy)
      if child.layout == .screen {
        continue
      }
      r := rect::Rect{x, y+sy, sz.x, sz.y}
      ui.retained[child.id].rect = r
      child.rect = r
      sy += r.h
      sx = sx > r.w ? sx : r.w
    } else {
      sz := ui.layout(child, node.pos.x, node.pos.y)
      r := rect::Rect{node.pos.x, node.pos.y, sz.x, sz.y}
      ui.retained[child.id].rect = r
      child.rect = r
      sy = sy > r.h ? sy : r.h
      sx = sx > r.w ? sx : r.w
    }
  }

  if springTotal != 0.0 {
    psx, psy := sx, sy
    projectedSizeX, projectedSizeY := 0.0, 0.0
    if node.sizeOverride != 0 { 
      if node.layout == .row {
        projectedSizeX = node.sizeOverride
      } 
      if node.layout == .col {
        projectedSizeY= node.sizeOverride
      }
    }

    sx, sy = 0, 0
    x, y = initX, initY

    for i, child^ in node.children {
      if child.justify != 0.0 {
        if node.layout == .row {
          ui.layout(child, x+sx, y)
          d := (projectedSizeX-psx)/springTotal*child.justify
          child.rect = rect::Rect{x+sx, y, d, psy}
          sx += d
        } else if node.layout == .col {
          ui.layout(child, x, y+sy)
          d := (projectedSizeY-psy)/springTotal*child.justify
          sy += d
        }
      } else if node.layout == .row {
        sz := ui.layout(child, x+sx, y)
        if child.layout == .screen {
          continue
        }
        r := rect::Rect{x+sx, y, sz.x, sz.y}
        ui.retained[child.id].rect = r
        child.rect = r
        sx += r.w
        sy = sy > r.h ? sy : r.h
      } else if node.layout == .col {
        sz := ui.layout(child, x, y+sy)
        if child.layout == .screen {
          continue
        }
        r := rect::Rect{x, y+sy, sz.x, sz.y}
        ui.retained[child.id].rect = r
        child.rect = r
        sy += r.h
        sx = sx > r.w ? sx : r.w
      } else {
        sz := ui.layout(child, node.pos.x, node.pos.y)
        r := rect::Rect{node.pos.x, node.pos.y, sz.x, sz.y}
        ui.retained[child.id].rect = r
        child.rect = r
        sy = sy > r.h ? sy : r.h
        sx = sx > r.w ? sx : r.w
      }
    }
  }

  if node.sizeOverride != 0 { 
    if node.layout == .row {
      sx = node.sizeOverride
    } 
    if node.layout == .col {
      sy = node.sizeOverride
    }
  }

  return th::Vf2{node.size.x+node.padding*2+sx, node.size.y+node.padding*2+sy}
}

fn (ui: ^UI) render(node: ^El, render: RenderFn) {
  render(ui, node.rect, node)

  for i, child^ in node.children {
    ui.render(child, render)
  }
}

fn (ui: ^UI) drawDebug(el: ^El, hue: real = 0);
fn (ui: ^UI) drawDebug2(el: ^El, hue: real = 0);

fn (ui: ^UI) pass*(cb: fn(ui: ^UI), render: RenderFn, debug: bool = false) {
  ui.uniq = 0
  ui.root = new(El)
  ui.parents = {ui.root}
  ui.ids = {fnv1::INIT}
  cb(ui)

  // calculate layout
  ui.layout(ui.root, 300, 300)
  ui.render(ui.root, render)

  filtered := map[uint]Retained{}

  for i, r in ui.retained {
    r.life -= 1
    if r.life > 0 {
      filtered[i] = r
    }
  }

  ui.retained = filtered

  delete(ui.retained, 0)

  if debug {
    ui.drawDebug(ui.root)
    ui.drawDebug2(ui.root)
  }
}

fn (ui: ^UI) addEl*(): ^El {
  el := El{parent: ui.parents[len(ui.parents)-1]}
  el.parent.children = append(el.parent.children, el)
  return &el.parent.children[len(el.parent.children)-1]
}

fn (ui: ^UI) pushEl*(): ^El {
  parent := ui.parents[len(ui.parents)-1]
  el := El{
    parent: parent
  }
  parent.children = append(parent.children, el)
  child := &parent.children[len(parent.children)-1]
  ui.parents = append(ui.parents, child)

  return child
}

fn (ui: ^UI) popEl*() {
  ui.parents = delete(ui.parents, len(ui.parents)-1)
}

fn (ui: ^UI) pushIdInt*(i: int) {
  id := fnv1::hash64i(ui.ids[len(ui.ids)-1], i)
  ui.retained[id].id = i
  ui.retained[id].life = 2
  ui.ids = append(ui.ids, uint(i))
}

fn (ui: ^UI) pushIdStr*(s: str) {
  id := fnv1::hash64s(ui.ids[len(ui.ids)-1], s)
  ui.retained[id].id = s
  ui.retained[id].life = 2
  ui.ids = append(ui.ids, id)
}

fn (ui: ^UI) popId*() {
  ui.uniq++
  ui.ids = delete(ui.ids, len(ui.ids)-1)
}

fn (ui: ^UI) id*(): uint {
  return ui.ids[len(ui.ids)-1]
}

// ------------- WIDGETS
fn (ui: ^UI) img*(img: image::Image) {
  el := ui.addEl()
  el.img = img
  el.size = img.getDims()
}

fn (ui: ^UI) img2*(img: image::Image, r: rect::Rect) {
  el := ui.addEl()
  el.img = img
  el.crop = r
  el.size = r.getDims()
}

fn (ui: ^UI) label*(text: str) {
  el := ui.addEl()
  el.label = true
  el.size = ui.font.measure(text)
  el.text = text
}

fn (ui: ^UI) button*(text: str): bool {
  ui.pushIdStr(text)
  el := ui.pushEl()

  el.justify = 2
  el.id = ui.id()
  el.padding = 10

  ui.label(text)

  retained := ui.retained[el.id].rect
  pressed := input::isJustPressed(.mouse1) && coll::vf2ToRect(input::getMousePos(), retained)

  ui.popEl()
  ui.popId()

  return pressed
}

fn (ui: ^UI) button2*(name: str, cb: fn(ui: ^UI)): bool {
  ui.pushIdStr(name)
  el := ui.pushEl()

  el.id = ui.id()
  el.padding = 5

  cb(ui)

  retained := ui.retained[el.id].rect
  pressed := input::isJustPressed(.mouse1) && coll::vf2ToRect(input::getMousePos(), retained)

  ui.popEl()
  ui.popId()

  return pressed
}

fn (ui: ^UI) spring*(power: real) {
  el := ui.addEl()
  el.layout = .spring
  el.label = true
  el.justify = power
}

fn (ui: ^UI) row*(cb: fn(ui: ^UI), width: int = 0) {
  el := ui.pushEl()
  el.sizeOverride = width
  el.layout = .row
  el.padding = 10
  el.label = true
  cb(ui)
  ui.popEl()
}

fn (ui: ^UI) col*(cb: fn(ui: ^UI), height: int = 0) {
  el := ui.pushEl()
  el.sizeOverride = height
  el.padding = 10
  el.layout = .col
  el.label = true
  cb(ui)
  ui.popEl()
}

fn (ui: ^UI) screen*(at: th::Vf2, cb: fn(ui: ^UI)) {
  el := ui.pushEl()
  el.padding = 10
  el.layout = .screen
  el.label = true
  el.pos = at
  cb(ui)
  ui.popEl()
}

fn (ui: ^UI) buttonOLD*(text: str, rect: rect::Rect, invert: bool = false): bool {
  return false
}

// ------------- DEBUG
fn (ui: ^UI) drawDebug(el: ^El, hue: real = 0) {
  for i, child^ in el.children {
    ui.drawDebug(child, hue+0.25)
  }

  if el.layout == .spring {
    util::drawArrow2({el.rect.x, el.rect.y+el.rect.h/2}, {el.rect.x+el.rect.w, el.rect.y+el.rect.h/2}, color::hsv(hue, 1.0, 0.6, 1.0))
  }

  if coll::vf2ToRect(input::getMousePos(), el.rect) {
    canvas::drawRectLines(color::hsv(hue, 1.0, 0.6, 1.0), el.rect, 2)
  } else {
    canvas::drawRectLines(color::hsv(hue, 1.0, 0.6, 0.4), el.rect, 1)
  }
}

fn (ui: ^UI) drawDebug2(el: ^El, hue: real = 0) {
  id := ui.retained[el.id].id
  if selfhasptr(id) && coll::vf2ToRect(input::getMousePos(), el.rect) {
    rect := color::hsv(hue, 1.0, 0.8, 0.6)
    text := color::hsv(hue, 1.0, 0.4, 1.0)

    strId := sprintf("%v", id)
    sz := ui.font.measure(strId).mulf(0.5)
    canvas::drawRect(rect, rect::Rect{el.rect.x, el.rect.y-sz.y, sz.x, sz.y})
    ui.font.draw(strId, el.rect.getPos().sub({0, sz.y}), text, 0.5)
  }

  for i, child^ in el.children {
    ui.drawDebug2(child, hue+0.25)
  }
}

