// Main UI controller

import (
  "std.um"
  "canvas.um"
  "rect.um"
  "th.um"
  "input.um"
  "coll.um"
  "font.um"
  "image.um"
  "../misc/fnv1.um"
)

type (
  RenderFn* = fn(ui: ^UI, r: rect::Rect, el: ^El)

  LayoutType* = enum {
    col
    row
    screen
  }

  RenderCall* = struct {
    r: rect::Rect
    el: ^El
  }

  El* = struct {
    parent: weak ^El
    children: []El
    layout: LayoutType
    pos: th::Vf2
    label: bool
    id: uint
    padding: real
    crop: rect::Rect
    size: th::Vf2
    img: image::Image
    text: str
  }

  Retained* = struct {
    life: int
    id: any
    rect: rect::Rect
  }

  UI* = struct {
    uniq: uint
    font: font::Font
    retained: map[uint]Retained
    ids: []uint
    parents: []^El
    root: ^El
  }
)

fn mk*(): UI {
  return {font: canvas::pixelFont}
}

fn (ui: ^UI) layout(renders: ^[]RenderCall, node: ^El, x, y: real): th::Vf2 {
  if node == null {
    return {}
  }

  sx, sy := 0.0, 0.0
  x += node.padding
  y += node.padding

  for i, child^ in node.children {
    if node.layout == .row {
      sz := ui.layout(renders, child, x+sx, y)
      r := rect::Rect{x+sx, y, sz.x, sz.y}
      ui.retained[child.id].rect = r
      renders ^= append(renders^, RenderCall{r, child})
      sx += r.w
      sy = sy > r.h ? sy : r.h
    } else if node.layout == .col {
      sz := ui.layout(renders, child, x, y+sy)
      r := rect::Rect{x, y+sy, sz.x, sz.y}
      ui.retained[child.id].rect = r
      renders ^= append(renders^, RenderCall{r, child})
      sy += r.h
      sx = sx > r.w ? sx : r.w
    } else {
      sz := ui.layout(renders, child, node.pos.x, node.pos.y)
      r := rect::Rect{node.pos.x, node.pos.y, sz.x, sz.y}
      ui.retained[child.id].rect = r
      renders ^= append(renders^, RenderCall{r, child})
      sy = sy > r.h ? sy : r.h
      sx = sx > r.w ? sx : r.w
    }
  }

  return th::Vf2{node.size.x+node.padding*2+sx, node.size.y+node.padding*2+sy}
}

fn (ui: ^UI) pass*(cb: fn(ui: ^UI), render: RenderFn) {
  ui.uniq = 0
  ui.root = new(El)
  ui.parents = {ui.root}
  ui.ids = {fnv1::INIT}
  cb(ui)

  renders := []RenderCall{}

  // calculate layout
  ui.layout(&renders, ui.root, 0, 0)

  for i in renders {
    r := renders[len(renders)-i-1]
    render(ui, r.r, r.el)
  }

  filtered := map[uint]Retained{}

  for i, r in ui.retained {
    r.life -= 1
    if r.life > 0 {
      filtered[i] = r
    }
  }

  ui.retained = filtered

  delete(ui.retained, 0)
}

fn (ui: ^UI) pushEl*(): ^El {
  parent := ui.parents[len(ui.parents)-1]
  el := El{
    parent: parent
  }
  parent.children = append(parent.children, el)
  child := &parent.children[len(parent.children)-1]
  ui.parents = append(ui.parents, child)

  return child
}

fn (ui: ^UI) popEl*() {
  ui.parents = delete(ui.parents, len(ui.parents)-1)
}

fn (ui: ^UI) pushIdInt*(i: int) {
  id := fnv1::hash64i(ui.ids[len(ui.ids)-1], i)
  ui.retained[id].id = i
  ui.retained[id].life = 2
  ui.ids = append(ui.ids, uint(i))
}

fn (ui: ^UI) pushIdStr*(s: str) {
  id := fnv1::hash64s(ui.ids[len(ui.ids)-1], s)
  ui.retained[id].id = s
  ui.retained[id].life = 2
  ui.ids = append(ui.ids, id)
}

fn (ui: ^UI) popId*() {
  ui.uniq++
  ui.ids = delete(ui.ids, len(ui.ids)-1)
}

fn (ui: ^UI) id*(): uint {
  return ui.ids[len(ui.ids)-1]
}

// ------------- WIDGETS
fn (ui: ^UI) img*(img: image::Image) {
  el := ui.pushEl()
  el.img = img
  el.size = img.getDims()
  ui.popEl()
}

fn (ui: ^UI) img2*(img: image::Image, r: rect::Rect) {
  el := ui.pushEl()
  el.img = img
  el.crop = r
  el.size = r.getDims()
  ui.popEl()
}

fn (ui: ^UI) label*(text: str) {
  el := ui.pushEl()
  el.label = true
  el.size = ui.font.measure(text)
  el.text = text
  ui.popEl()
}

fn (ui: ^UI) button*(text: str): bool {
  ui.pushIdStr(text)
  el := ui.pushEl()

  el.id = ui.id()
  el.padding = 10

  ui.label(text)

  retained := ui.retained[el.id].rect
  pressed := input::isJustPressed(.mouse1) && coll::vf2ToRect(input::getMousePos(), retained)

  ui.popEl()
  ui.popId()

  return pressed
}

fn (ui: ^UI) button2*(name: str, cb: fn(ui: ^UI)): bool {
  ui.pushIdStr(name)
  el := ui.pushEl()

  el.id = ui.id()
  el.padding = 5

  cb(ui)

  retained := ui.retained[el.id].rect
  pressed := input::isJustPressed(.mouse1) && coll::vf2ToRect(input::getMousePos(), retained)

  ui.popEl()
  ui.popId()

  return pressed
}

fn (ui: ^UI) row*(cb: fn(ui: ^UI)) {
  ui.pushIdStr(sprintf("Row (%v)", ui.uniq))
  el := ui.pushEl()
  el.id = ui.id()
  el.layout = .row
  el.padding = 10
  el.label = true
  cb(ui)
  ui.popEl()
  ui.popId()
}

fn (ui: ^UI) col*(cb: fn(ui: ^UI)) {
  ui.pushIdStr(sprintf("Col (%v)", ui.uniq))
  el := ui.pushEl()
  el.id = ui.id()
  el.padding = 10
  el.label = true
  cb(ui)
  ui.popEl()
  ui.popId()
}

fn (ui: ^UI) screen*(at: th::Vf2, cb: fn(ui: ^UI)) {
  ui.pushIdStr(sprintf("Scr (%v)", ui.uniq))
  el := ui.pushEl()
  el.id = ui.id()
  el.padding = 10
  el.layout = .screen
  el.label = true
  el.pos = at
  cb(ui)
  ui.popEl()
  ui.popId()
}


fn (ui: ^UI) buttonOLD*(text: str, rect: rect::Rect, invert: bool = false): bool {
  return false
}

// ------------- DEBUG
fn (ui: ^UI) drawDebug*() {
  for id, r in ui.retained {
    canvas::drawRectLines(0xff0000ff, r.rect, 1)
    sz := ui.font.measure(sprintf("%v", r.id)).mulf(0.5)
    canvas::drawRect(0xff000022, rect::Rect{r.rect.x, r.rect.y, sz.x, sz.y})
    ui.font.draw(sprintf("%v", r.id), r.rect.getPos(), 0x770000FF, 0.5)
  }
}
