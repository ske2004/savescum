// TODO: Make the element struct smaller in size
//       Fix duplicate in layouts
//       Aligning rows and columns
//       Hovering effects?

import (
  "std.um"
  "canvas.um"
  "rect.um"
  "th.um"
  "input.um"
  "coll.um"
  "font.um"
  "image.um"
  "color.um"
  "window.um"
  "../misc/immcursor.um"
  "../misc/util.um"
  "../misc/fnv1.um"
)

// >>> TYPES >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

type (
  LayoutType* = enum {
    col
    row
    spring
    screen
  }

  BoxRenderer* = interface {
    draw(rect: rect::Rect)
  }

  BoxStyle* = enum {
    none
    button
    window
    titlebar
    input
    highlighted
    toolbar
    _count
  }

  BoxState* = struct {
    pressed: bool
    hovered: bool
    focused: bool
  }

  BoxTheme* = struct {
    normal: BoxRenderer
    hovered: BoxRenderer
    pressed: BoxRenderer
    focused: BoxRenderer
  }

  RenderCall* = struct {
    r: rect::Rect
    el: ^El
  }

  CellKind* = enum {
    justify
    rect
  }

  Cell* = struct {
    kind: CellKind
    justify: real
    align: real
    rect: rect::Rect
  }

  El* = struct {
    parent: weak ^El
    sizeOverride: real
    cell: Cell
    rect: rect::Rect
    children: []El
    layout: LayoutType
    pos: th::Vf2
    label: bool
    id: uint
    padding: real
    crop: rect::Rect
    size: th::Vf2
    img: image::Image
    text: str
    boxStyle: BoxStyle
  }

  Retained* = struct {
    life: int
    id: any
    rect: rect::Rect
    state: BoxState
    boxStyle: BoxStyle
  }

  Attention* = struct {
    focused: uint
    active: uint
    hovered: uint
  }

  UI* = struct {
    uniq: uint
    font: font::Font
    retained: map[uint]Retained
    theme: [int(BoxStyle._count)]BoxTheme
    cursors: [int(BoxStyle._count)]window::Cursor
    ids: []uint
    attention: Attention
    parents: []^El
    root: ^El
    cell: Cell
  }
)

// >>> FUNCTIONS >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

fn mk*(): UI {
  return {font: canvas::pixelFont}
}

fn (ui: ^UI) layout(node: ^El, x, y: real): th::Vf2 {
  if node == null {
    return {}
  }

  sx, sy := 0.0, 0.0
  x += node.padding
  y += node.padding
  initX, initY := x, y

  springTotal := 0.0

  sizes := map[uint]th::Vf2{}

  for i, child^ in node.children {
    springTotal += child.cell.justify

    if child.cell.justify != 0 && node.layout != .screen {
      continue
    }

    if node.layout == .row {
      sz := ui.layout(child, x+sx, y)
      if child.layout == .screen {
        continue
      }
      r := rect::Rect{x+sx, y, sz.x, sz.y}
      ui.retained[child.id].rect = r
      child.rect = r
      sx += r.w
      sy = sy > r.h ? sy : r.h
      sizes[i] = sz
    } else if node.layout == .col {
      sz := ui.layout(child, x, y+sy)
      if child.layout == .screen {
        continue
      }
      r := rect::Rect{x, y+sy, sz.x, sz.y}
      ui.retained[child.id].rect = r
      child.rect = r
      sy += r.h
      sx = sx > r.w ? sx : r.w
      sizes[i] = sz
    } else {
      sz := ui.layout(child, node.pos.x, node.pos.y)
      r := rect::Rect{node.pos.x, node.pos.y, sz.x, sz.y}
      ui.retained[child.id].rect = r
      child.rect = r
      sy = sy > r.h ? sy : r.h
      sx = sx > r.w ? sx : r.w
    }
  }

  if springTotal != 0.0 {
    psx, psy := sx, sy
    projectedSizeX, projectedSizeY := psx, psy
    if node.sizeOverride != 0 { 
      if node.layout == .row {
        projectedSizeX = node.sizeOverride
      } 
      if node.layout == .col {
        projectedSizeY= node.sizeOverride
      }
    }

    sx, sy = 0, 0
    x, y = initX, initY

    for i, child^ in node.children {
      if child.cell.justify != 0.0 || child.cell.align != 0.0 {
        if node.layout == .row {
          d := (projectedSizeX-psx)/springTotal*child.cell.justify
          child.sizeOverride = d-2*child.padding
          csz := ui.layout(child, x+sx, y)
          if csz.y > psy {psy = csz.y}
          child.rect = rect::Rect{x+sx, y, d, psy}
          sx += d
          sy = sy > csz.y ? sy : csz.y
        } else if node.layout == .col {
          d := (projectedSizeY-psy)/springTotal*child.cell.justify
          child.sizeOverride = d-2*child.padding
          ui.layout(child, x, y+sy)
          sy += d
        }
      } else if node.layout == .row {
        sz := ui.layout(child, x+sx, y+(psy-sizes[i].y)*node.cell.align)
        if child.layout == .screen {
          continue
        }
        r := rect::Rect{x+sx, y+(psy-sizes[i].y)*node.cell.align, sz.x, sz.y}
        ui.retained[child.id].rect = r
        child.rect = r
        sx += r.w
        sy = sy > r.h ? sy : r.h
      } else if node.layout == .col {
        sz := ui.layout(child, x, y+sy)
        if child.layout == .screen {
          continue
        }
        r := rect::Rect{x, y+sy, sz.x, sz.y}
        ui.retained[child.id].rect = r
        child.rect = r
        sy += r.h
        sx = sx > r.w ? sx : r.w
      } else {
        sz := ui.layout(child, node.pos.x, node.pos.y)
        r := rect::Rect{node.pos.x, node.pos.y, sz.x, sz.y}
        ui.retained[child.id].rect = r
        child.rect = r
        sy = sy > r.h ? sy : r.h
        sx = sx > r.w ? sx : r.w
      }
    }
  }

  if node.sizeOverride != 0 { 
    if node.layout == .row {
      sx = node.sizeOverride
    } 
    if node.layout == .col {
      sy = node.sizeOverride
    }
  }

  return th::Vf2{node.size.x+node.padding*2+sx, node.size.y+node.padding*2+sy}
}

fn (ui: ^UI) processAttentionRec(el: ^El) {
  if el.id != 0 && coll::vf2ToRect(input::getMousePos(), el.rect) {
    ui.attention.hovered = el.id
  }

  if el.id != 0 && input::isJustPressed(.mouse1) && coll::vf2ToRect(input::getMousePos(), el.rect) {
    ui.attention.active = el.id
    ui.attention.focused = el.id
  }

  for i, child^ in el.children {
    ui.processAttentionRec(child)
  }
}

fn (ui: ^UI) processAttention(el: ^El) {
  ui.attention.hovered = 0

  if input::isJustPressed(.mouse1) {
    ui.attention.focused = 0
  }

  if input::isJustReleased(.mouse1) {
    ui.attention.active = 0
  }

  ui.processAttentionRec(el)
}

fn (ui: ^UI) input(el: ^El) {
  ui.retained[el.id].state.hovered = ui.attention.hovered == el.id
  ui.retained[el.id].state.pressed = ui.attention.active == el.id

  for i, child^ in el.children {
    ui.input(child)
  }
}

fn (ui: ^UI) render(el: ^El) {
  theme := ui.theme[int(el.boxStyle)]

  retained := ui.retained[el.id]

  if selfhasptr(theme.pressed) && retained.state.pressed {
    theme.pressed.draw(el.rect)
  } else if selfhasptr(theme.normal) {
    theme.normal.draw(el.rect)
  }

  if el.img.validate() {
    el.img.blit(el.crop, el.rect)
  }

  ui.font.draw(el.text, {el.rect.x+el.padding, el.rect.y+el.padding}, 0x000000FF)

  for i, child^ in el.children {
    ui.render(child)
  }
}

fn (ui: ^UI) updateCursor() {
  if ui.attention.active != 0 {
    immcursor::setCursor(ui.cursors[int(ui.retained[ui.attention.active].boxStyle)])
  } else if ui.attention.hovered != 0 {
    immcursor::setCursor(ui.cursors[int(ui.retained[ui.attention.hovered].boxStyle)])
  }
}

fn (ui: ^UI) drawDebug(el: ^El, hue: real = 0);
fn (ui: ^UI) drawDebug2(el: ^El, hue: real = 0);

fn (ui: ^UI) pass*(cb: fn(ui: ^UI), debug: bool = false) {
  ui.uniq = 0
  ui.root = new(El)
  ui.parents = {ui.root}
  ui.ids = {fnv1::INIT}
  cb(ui)

  // calculate layout
  ui.layout(ui.root, 0, 0)
  ui.processAttention(ui.root)
  ui.input(ui.root)
  ui.updateCursor()
  ui.render(ui.root)

  filtered := map[uint]Retained{}

  for i, r in ui.retained {
    r.life -= 1
    if r.life > 0 {
      filtered[i] = r
    }
  }

  ui.retained = filtered

  delete(ui.retained, 0)

  if debug {
    ui.drawDebug(ui.root)
    ui.drawDebug2(ui.root)
  }
}

// >>> INTERNALS >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

fn (ui: ^UI) addEl*(): ^El {
  el := El{parent: ui.parents[len(ui.parents)-1]}
  el.cell = ui.cell
  ui.cell = {}
  el.parent.children = append(el.parent.children, el)
  return &el.parent.children[len(el.parent.children)-1]
}

fn (ui: ^UI) lastEl*(): ^El {
  return ui.parents[len(ui.parents)-1]
}

fn (ui: ^UI) pushEl*(): ^El {
  parent := ui.parents[len(ui.parents)-1]
  el := El{
    parent: parent,
    cell: ui.cell
  }
  ui.cell = {}
  parent.children = append(parent.children, el)
  child := &parent.children[len(parent.children)-1]
  ui.parents = append(ui.parents, child)

  return child
}

fn (ui: ^UI) popEl*() {
  ui.parents = delete(ui.parents, len(ui.parents)-1)
}

fn (ui: ^UI) pushIdInt*(i: int) {
  id := fnv1::hash64i(ui.ids[len(ui.ids)-1], i)
  ui.retained[id].id = i
  ui.retained[id].life = 2
  ui.ids = append(ui.ids, uint(i))
}

fn (ui: ^UI) pushIdStr*(s: str) {
  id := fnv1::hash64s(ui.ids[len(ui.ids)-1], s)
  ui.retained[id].id = s
  ui.retained[id].life = 2
  ui.ids = append(ui.ids, id)
}

fn (ui: ^UI) popId*() {
  ui.uniq++
  ui.ids = delete(ui.ids, len(ui.ids)-1)
}

fn (ui: ^UI) id*(): uint {
  return ui.ids[len(ui.ids)-1]
}

// >>> STYLING >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

fn (ui: ^UI) boxStyle*(style: BoxStyle) {
  ui.lastEl().boxStyle = style
  ui.retained[ui.lastEl().id].boxStyle = style
}

fn (ui: ^UI) setBoxTheme*(style: BoxStyle, theme: BoxTheme) {
  ui.theme[int(style)] = theme
}

fn (ui: ^UI) setBoxCursor*(style: BoxStyle, cursor: window::Cursor) {
  ui.cursors[int(style)] = cursor
}

// >>> CELLS >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

fn (ui: ^UI) cellRect*(r: rect::Rect) {
  ui.cell = Cell{kind: .rect, rect: r}
}

fn (ui: ^UI) cellJustify*(j: real) {
  ui.cell = Cell{kind: .justify, justify: j}
}

// >>> WIDGETS >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

fn (ui: ^UI) img*(img: image::Image) {
  el := ui.addEl()
  el.img = img
  el.size = img.getDims()
  el.crop = {0, 0, el.size.x, el.size.y}
}

fn (ui: ^UI) img2*(img: image::Image, r: rect::Rect) {
  el := ui.addEl()
  el.img = img
  el.crop = r
  el.size = r.getDims()
}

fn (ui: ^UI) label*(text: str) {
  el := ui.addEl()
  el.label = true
  el.size = ui.font.measure(text)
  el.text = text
}

fn (ui: ^UI) spring*(power: real)
fn (ui: ^UI) button*(text: str): bool {
  ui.pushIdStr(text)
  el := ui.pushEl()
  el.id = ui.id()
  ui.boxStyle(.button)

  el.layout = .row
  el.padding = 10
  el.cell.align = 0.5

  ui.spring(1)
  ui.label(text)
  ui.spring(1)

  retained := ui.retained[el.id].rect
  pressed := input::isJustReleased(.mouse1) && 
             ui.attention.hovered == el.id &&
             ui.attention.focused == el.id

  ui.popEl()
  ui.popId()

  return pressed
}

fn (ui: ^UI) button2*(name: str, cb: fn(ui: ^UI)): bool {
  ui.pushIdStr(name)
  el := ui.pushEl()
  el.id = ui.id()
  ui.boxStyle(.button)

  el.padding = 5

  cb(ui)

  retained := ui.retained[el.id].rect
  pressed := input::isJustReleased(.mouse1) && 
             ui.attention.hovered == el.id &&
             ui.attention.focused == el.id
  
  ui.popEl()
  ui.popId()

  return pressed
}

fn (ui: ^UI) spring*(power: real) {
  el := ui.addEl()
  el.layout = .spring
  el.label = true
  el.cell.kind = .justify
  el.cell.justify = power
}

fn (ui: ^UI) row*(cb: fn(ui: ^UI), width: int = 0): ^El {
  el := ui.pushEl()
  el.sizeOverride = width
  el.layout = .row
  el.label = true
  cb(ui)
  ui.popEl()

  return el
}

fn (ui: ^UI) col*(cb: fn(ui: ^UI), height: int = 0) {
  el := ui.pushEl()
  el.sizeOverride = height
  el.layout = .col
  el.label = true
  cb(ui)
  ui.popEl()
}

fn (ui: ^UI) screen*(at: th::Vf2, cb: fn(ui: ^UI)) {
  el := ui.pushEl()
  el.layout = .screen
  el.label = true
  el.pos = at
  cb(ui)
  ui.popEl()
}

// HACK: Just to make the editor compile while there's old code.
fn (ui: ^UI) buttonOLD*(text: str, rect: rect::Rect, invert: bool = false): bool {
  return false
}

// >>> DEBUG >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

// NOTE: Step 1 in debug UI, draws the outlines.
fn (ui: ^UI) drawDebug(el: ^El, hue: real = 0) {
  for i, child^ in el.children {
    ui.drawDebug(child, hue+0.25)
  }

  if el.layout == .spring {
    util::drawArrow2(
      {el.rect.x, el.rect.y+el.rect.h/2},
      {el.rect.x+el.rect.w, el.rect.y+el.rect.h/2},
      color::hsv(hue, 1.0, 0.6, 1.0)
    )
  }

  if coll::vf2ToRect(input::getMousePos(), el.rect) {
    canvas::drawRectLines(color::hsv(hue, 1.0, 0.6, 1.0), el.rect, 2)
  } else {
    canvas::drawRectLines(color::hsv(hue, 1.0, 0.6, 0.4), el.rect, 1)
  }

  if el.id != 0 && ui.attention.focused == el.id {
    canvas::drawRectLines(0xFF0000FF, el.rect, 4)
  }
}

// NOTE: Step 2 in debug UI, draws the ID of hovered elements.
fn (ui: ^UI) drawDebug2(el: ^El, hue: real = 0) {
  id := ui.retained[el.id].id
  if selfhasptr(id) && coll::vf2ToRect(input::getMousePos(), el.rect) {
    rect := color::hsv(hue, 1.0, 0.8, 0.6)
    text := color::hsv(hue, 1.0, 0.4, 1.0)

    strId := sprintf("%v", id)
    sz := ui.font.measure(strId).mulf(0.5)
    canvas::drawRect(rect, rect::Rect{el.rect.x, el.rect.y-sz.y, sz.x, sz.y})
    ui.font.draw(strId, el.rect.getPos().sub({0, sz.y}), text, 0.5)
  }

  for i, child^ in el.children {
    ui.drawDebug2(child, hue+0.25)
  }
}
