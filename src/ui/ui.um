// Main UI controller

import (
  "core.um"
  "atoms.um"
  "rect.um"
)

type El* = struct {
  id: str
  rect: rect::Rect
}

type UI* = struct {
  el: El
  core: core::Core
}

fn mk*(): UI {
  return {
    core: core::mk()
  }
}

// Creates a space with a default "screen" container for you to use.
fn (ui: ^UI) space*(id: str, r: rect::Rect, cb: fn(ui: ^UI)) {
  ui.core.beginTool(id, r)
  pel := ui.el
  ui.el = El{id: id, rect: r}
  cb(ui)
  ui.core.endTool()
  ui.el = pel
}

// Allows to hijack a tool and use it as a space.
fn (ui: ^UI) hack*(id: str, cb: fn(ui: ^UI)) {
  tool := ui.core.maybeAcquireToolNode(id)

  if tool != null {
    ui.space(id, tool.rect, cb)
  }
}

// ------------- STATES
fn (ui: ^UI) isHovered*(): bool {
  return ui.core.currentTool == ui.core.hoveredTool
}

fn (ui: ^UI) isPressed*(): bool {
  return ui.core.currentTool == ui.core.activeTool && ui.core.mouseState.lmb.isDown
}

// ------------- EVENTS

fn (ui: ^UI) onClick*(handler: fn(ui: ^UI)) {
  if ui.core.currentTool == ui.core.hoveredTool && ui.core.mouseState.lmb.isReleased {
    handler(ui)
  }
}
