// @TODO: Make the element struct smaller in size
// @TODO: Aligning rows and columns
// @TODO: Hovering effects?
// @TODO: Element pooling

import (
  "std.um"
  "canvas.um"
  "rect.um"
  "th.um"
  "input.um"
  "coll.um"
  "font.um"
  "image.um"
  "color.um"
  "window.um"
  "../misc/immcursor.um"
  "../misc/util.um"
  "../misc/fnv1.um"
)

// >>> TYPES >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

type (
  LayoutType* = enum {
    col
    row
    spring
  }

  BoxRenderer* = interface {
    draw(rect: rect::Rect)
  }

  BoxStyle* = enum {
    none
    button
    window
    titlebar
    input
    highlighted
    toolbar
    _count
  }

  BoxState* = struct {
    pressed: bool
    hovered: bool
    focused: bool
  }

  BoxTheme* = struct {
    normal: BoxRenderer
    hovered: BoxRenderer
    pressed: BoxRenderer
    focused: BoxRenderer
  }

  RenderCall* = struct {
    r: rect::Rect
    el: ^El
  }

  CellKind* = enum {
    normal
    justify
    rect
  }

  Cell* = struct {
    kind: CellKind
    justify: real
    align: real
    rect: rect::Rect
  }

  El* = struct {
    parent: weak ^El
    children: []^El
    id: uint

    layout: LayoutType
    size: th::Vf2
    contentSize: th::Vf2
    cell: Cell
    padding: real

    // Rendering info @TODO: Move to an interface instead.
    crop: rect::Rect
    img: image::Image
    text: str
    boxStyle: BoxStyle
  }

  Retained* = struct {
    life: int
    id: any
    rect: rect::Rect
    state: BoxState
    boxStyle: BoxStyle
  }

  Attention* = struct {
    focused: uint
    active: uint
    hovered: uint
  }

  UI* = struct {
    uniq: uint
    font: font::Font
    retained: map[uint]Retained
    theme: [int(BoxStyle._count)]BoxTheme
    cursors: [int(BoxStyle._count)]window::Cursor
    ids: []uint
    attention: Attention
    parents: []^El
    root: ^El
    cell: Cell
  }
)

// >>> FUNCTIONS >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

fn mk*(): UI {
  return {font: canvas::pixelFont}
}

fn (ui: ^UI) layout1(node: ^El): th::Vf2 {
  // Calculate the natural size unless the size is already known.
  size := th::Vf2{0, 0}
  for i, child in node.children {
    childSize := ui.layout1(child)
    if child.cell.kind == .rect {
      continue
    }
    if node.layout == .row {
      if child.cell.kind != .justify { size.x += childSize.x }
      size.y = util::max(size.y, childSize.y)
    } else if node.layout == .col {
      if child.cell.kind != .justify { size.y += childSize.y }
      size.x = util::max(size.x, childSize.x)
    }
  }

  node.contentSize = size.addf(node.padding*2)

  // Apply size overrides
  if node.size.x != 0 { size.x = node.size.x }
  if node.size.y != 0 { size.y = node.size.y }

  node.size = size.addf(node.padding*2)

  if node.cell.kind == .rect {
    node.size.x = node.cell.rect.w
    node.size.y = node.cell.rect.h
  }

  return node.size
}

fn (ui: ^UI) layout2(node: ^El, pos: th::Vf2) {
  if node.cell.kind != .rect {
    node.cell.rect.x, node.cell.rect.y = pos.x, pos.y
  } else {
    pos.x, pos.y = node.cell.rect.x, node.cell.rect.y
  }

  pos.x += node.padding
  pos.y += node.padding
    
  totalJustify := 0.0
  for i, child in node.children {
    totalJustify += child.cell.justify
  }

  for i, child in node.children {
    contentDiff := node.size.sub(node.contentSize)

    if child.cell.kind == .justify {
      if node.layout == .row {
        child.size.x = contentDiff.x * (child.cell.justify / totalJustify)
        child.size.y = node.size.y - node.padding * 2
      } else if node.layout == .col {
        child.size.y = contentDiff.y * (child.cell.justify / totalJustify)
        child.size.x = node.size.x - node.padding * 2
      }
    }

    alignedPos := pos
    if node.layout == .row  {
      alignedPos.y += (node.size.y - node.padding*2 - child.size.y) * node.cell.align
    } else if node.layout == .col {
      alignedPos.x += (node.size.x - node.padding*2 - child.size.x) * node.cell.align
    }

    ui.layout2(child, alignedPos)
    if node.layout == .row {
      pos.x += child.size.x
    } else if node.layout == .col {
      pos.y += child.size.y
    }
  }
}

fn (ui: ^UI) layout3(node: ^El) {
  node.cell.rect.w, node.cell.rect.h = node.size.x, node.size.y

  for i, child in node.children {
    ui.layout3(child)
  }
}

fn findClosestRetainedAncestorId(el: ^El): uint {
  if el.id == 0 && el.parent != null {
    return findClosestRetainedAncestorId(el.parent)
  }

  return el.id
}

fn (ui: ^UI) processAttentionRec(el: ^El) {
  // @MARK(DirectInput)
  if coll::vf2ToRect(input::getMousePos(), el.cell.rect) {
    id := findClosestRetainedAncestorId(el)
    ui.attention.hovered = id
    // @MARK(DirectInput)
    if input::isJustPressed(.mouse1) {
      ui.attention.active = id
      ui.attention.focused = id
    }
  }

  for i, child in el.children {
    ui.processAttentionRec(child)
  }
}

fn (ui: ^UI) processAttention(el: ^El) {
  ui.attention.hovered = 0

  // @MARK(DirectInput)
  if input::isJustPressed(.mouse1) {
    ui.attention.focused = 0
  }

  // @MARK(DirectInput)
  if input::isJustReleased(.mouse1) {
    ui.attention.active = 0
  }

  ui.processAttentionRec(el)
}

fn (ui: ^UI) input(el: ^El) {
  ui.retained[el.id].state.hovered = ui.attention.hovered == el.id
  ui.retained[el.id].state.pressed = ui.attention.active == el.id

  for i, child in el.children {
    ui.input(child)
  }
}

fn (ui: ^UI) render(el: ^El) {
  theme := ui.theme[int(el.boxStyle)]

  retained := ui.retained[el.id]

  if selfhasptr(theme.pressed) && retained.state.pressed {
    theme.pressed.draw(el.cell.rect)
  } else if selfhasptr(theme.normal) {
    theme.normal.draw(el.cell.rect)
  }

  if el.img.validate() {
    el.img.blit(el.crop, el.cell.rect)
  }

  if el.text != "" {
    ui.font.draw(el.text, {el.cell.rect.x+el.padding, el.cell.rect.y+el.padding}, 0x000000FF)
  }

  for i, child in el.children {
    ui.render(child)
  }
}

fn (ui: ^UI) updateCursor() {
  if ui.attention.active != 0 {
    immcursor::setCursor(ui.cursors[int(ui.retained[ui.attention.active].boxStyle)])
  } else if ui.attention.hovered != 0 {
    immcursor::setCursor(ui.cursors[int(ui.retained[ui.attention.hovered].boxStyle)])
  }
}

fn (ui: ^UI) drawDebug(el: ^El, hue: real = 0)
fn (ui: ^UI) drawDebug2(el: ^El, hue: real = 0, hy: real = 0)

fn (ui: ^UI) pass*(cb: fn(ui: ^UI), debug: bool = false) {
  ui.uniq = 0
  ui.root = new(El)
  ui.parents = {ui.root}
  ui.ids = {fnv1::INIT}
  cb(ui)

  // calculate layout
  ui.layout1(ui.root)
  ui.layout2(ui.root, {0, 0})
  ui.layout3(ui.root)
  ui.processAttention(ui.root)
  ui.input(ui.root)
  ui.updateCursor()
  ui.render(ui.root)

  if debug {
    ui.drawDebug(ui.root)
    ui.drawDebug2(ui.root)
  }

  filtered := map[uint]Retained{}

  for i, r in ui.retained {
    r.life -= 1
    if r.life > 0 {
      filtered[i] = r
    }
  }

  ui.retained = filtered

  delete(ui.retained, 0)
}

// >>> INTERNALS >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

fn (ui: ^UI) beginRoot*(): bool {
  ui.parents = append(ui.parents, ui.root)
  return true
}

fn (ui: ^UI) endRoot*(): bool {
  std::assert(ui.parents[len(ui.parents)-1] == ui.root)
  ui.parents = delete(ui.parents, len(ui.parents)-1)
  return true
}


fn (ui: ^UI) addEl*(): ^El {
  el := &El{
    parent: ui.parents[len(ui.parents)-1],
    cell: ui.cell
  }
  ui.cell = {}
  el.parent.children = append(el.parent.children, el)
  return el
}

fn (ui: ^UI) pushEl*(): ^El {
  parent := ui.parents[len(ui.parents)-1]

  el := &El{
    parent: parent,
    cell: ui.cell
  }
  ui.cell = {}
  parent.children = append(parent.children, el)
  ui.parents = append(ui.parents, el)

  return el
}

fn (ui: ^UI) lastEl*(): ^El {
  return ui.parents[len(ui.parents)-1]
}

fn (ui: ^UI) popEl*() {
  ui.parents = delete(ui.parents, len(ui.parents)-1)
}

fn (ui: ^UI) pushIdInt*(i: int) {
  id := fnv1::hash64i(ui.ids[len(ui.ids)-1], i)
  ui.retained[id].id = i
  ui.retained[id].life = 2
  ui.ids = append(ui.ids, uint(id))
  ui.lastEl().id = id
}

fn (ui: ^UI) pushIdStr*(s: str) {
  id := fnv1::hash64s(ui.ids[len(ui.ids)-1], s)
  ui.retained[id].id = s
  ui.retained[id].life = 2
  ui.ids = append(ui.ids, id)
  ui.lastEl().id = id
}

fn (ui: ^UI) popId*() {
  ui.uniq++
  ui.ids = delete(ui.ids, len(ui.ids)-1)
}

fn (ui: ^UI) id*(): uint {
  return ui.ids[len(ui.ids)-1]
}

// >>> STYLING >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

fn (ui: ^UI) boxStyle*(style: BoxStyle) {
  ui.lastEl().boxStyle = style
  ui.retained[ui.lastEl().id].boxStyle = style
}

fn (ui: ^UI) setBoxTheme*(style: BoxStyle, theme: BoxTheme) {
  ui.theme[int(style)] = theme
}

fn (ui: ^UI) setBoxCursor*(style: BoxStyle, cursor: window::Cursor) {
  ui.cursors[int(style)] = cursor
}

// >>> CELLS >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

fn (ui: ^UI) cellRect*(r: rect::Rect) {
  ui.cell = Cell{kind: .rect, rect: r}
}

fn (ui: ^UI) cellJustify*(j: real) {
  ui.cell = Cell{kind: .justify, justify: j}
}

// >>> EVENTS >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

fn (ui: ^UI) isHovered*(): bool {
  return ui.attention.hovered == ui.lastEl().id && ui.attention.active != 0
}

fn (ui: ^UI) isActive*(): bool {
  return ui.attention.active == ui.lastEl().id && ui.attention.active != 0
}

// >>> WIDGETS >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

fn (ui: ^UI) img*(img: image::Image) {
  el := ui.addEl()
  el.img = img
  el.size = img.getDims()
  el.crop = {0, 0, el.size.x, el.size.y}
}

fn (ui: ^UI) img2*(img: image::Image, r: rect::Rect) {
  el := ui.addEl()
  el.img = img
  el.crop = r
  el.size = r.getDims()
}

fn (ui: ^UI) label*(text: str) {
  el := ui.addEl()
  el.size = ui.font.measure(text)
  el.text = text
}

fn (ui: ^UI) spring*(power: real)
fn (ui: ^UI) button*(text: str): bool {
  el := ui.pushEl()
  ui.pushIdStr(text)
  ui.boxStyle(.button)

  el.layout = .row
  el.padding = 10
  el.cell.align = 0.5

  ui.spring(1)
  ui.label(text)
  ui.spring(1)

  retained := ui.retained[el.id].rect

  // @ROOT(DirectInput): Don't use `input` directly. 
  pressed := 
    input::isJustReleased(.mouse1) && 
    ui.attention.hovered == el.id &&
    ui.attention.focused == el.id

  ui.popId()
  ui.popEl()

  return pressed
}

fn (ui: ^UI) button2*(name: str, cb: fn(ui: ^UI)): bool {
  el := ui.pushEl()
  ui.pushIdStr(name)
  ui.boxStyle(.button)

  el.padding = 5

  cb(ui)

  retained := ui.retained[el.id].rect

  // @MARK(DirectInput)
  pressed := 
    input::isJustReleased(.mouse1) && 
    ui.attention.hovered == el.id &&
    ui.attention.focused == el.id
  
  ui.popId()
  ui.popEl()

  return pressed
}

fn (ui: ^UI) spring*(power: real) {
  el := ui.addEl()
  el.layout = .spring
  el.cell.kind = .justify
  el.cell.justify = power
}

fn (ui: ^UI) row*(cb: fn(ui: ^UI), width: int = 0): ^El {
  el := ui.pushEl()
  el.size.x = width
  el.layout = .row
  cb(ui)
  ui.popEl()

  return el
}

fn (ui: ^UI) col*(cb: fn(ui: ^UI), height: int = 0): ^El {
  el := ui.pushEl()
  el.size.y = height
  el.layout = .col
  cb(ui)
  ui.popEl()

  return el
}

// HACK: Just to make the editor compile while there's old code.
fn (ui: ^UI) buttonOLD*(text: str, rect: rect::Rect, invert: bool = false): bool {
  return false
}

// >>> DEBUG >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

// NOTE: Step 1 in debug UI, draws the outlines.
fn (ui: ^UI) drawDebug(el: ^El, hue: real = 0) {
  for i, child in el.children {
    ui.drawDebug(child, hue+0.25)
  }

  rect := el.cell.rect

  if el.layout == .spring {
    if el.parent.layout == .row {
      util::drawArrow2(
        {rect.x, rect.y+rect.h/2},
        {rect.x+rect.w, rect.y+rect.h/2},
        color::hsv(hue, 1.0, 0.6, 1.0)
      )
    } else {
      util::drawArrow2(
        {rect.x+rect.w/2, rect.y},
        {rect.x+rect.w/2, rect.y+rect.h},
        color::hsv(hue, 1.0, 0.6, 1.0)
      )
    }
  }

  // @MARK(DirectInput): Probably doesn't matter here.
  if coll::vf2ToRect(input::getMousePos(), rect) {
    canvas::drawRectLines(color::hsv(hue, 1.0, 0.6, 1.0), rect, 2)
  } else {
    canvas::drawRectLines(color::hsv(hue, 1.0, 0.6, 0.4), rect, 1)
  }

  if el.id != 0 && ui.attention.focused == el.id {
    canvas::drawRectLines(0xFF0000FF, rect, 4)
  }
}

// NOTE: Step 2 in debug UI, draws the ID of hovered elements.
fn (ui: ^UI) drawDebug2(el: ^El, hue: real = 0, hy: real = 0) {
  id := ui.retained[el.id].id
  rect := el.cell.rect

  // @MARK(DirectInput): Probably doesn't matter here.
  if coll::vf2ToRect(input::getMousePos(), rect) {
    border := color::hsv(hue, 1.0, 0.8, 0.6)
    text := color::hsv(hue, 1.0, 0.4, 1.0)

    if selfhasptr(id) {
      strId := sprintf("%v", id)
      sz := ui.font.measure(strId).mulf(0.5)
      canvas::drawRect(border, {rect.x, rect.y-sz.y, sz.x, sz.y})
      ui.font.draw(strId, rect.getPos().sub({0, sz.y}), text, 0.5)
    }

    info := sprintf("Id:%20v | LayoutType:%v | Active:%5v | Parent:%20v", el.id, el.layout, ui.attention.active == el.id, el.parent == null ? uint(0) : el.parent.id)
    sz := ui.font.measure(info).mulf(0.5)
    canvas::drawRect(border, {0, hy, sz.x, sz.y})
    ui.font.draw(info, {0, hy}, 0x000000FF, 0.5)
    hy += sz.y
  }

  for i, child in el.children {
    ui.drawDebug2(child, hue+0.25, hy)
  }
}
